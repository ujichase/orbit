<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Book of Orbit</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Book of Orbit</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-book-of-orbit"><a class="header" href="#the-book-of-orbit">The Book of Orbit</a></h1>
<p><img src="./images/orbit_logo_128px.png" alt="" /></p>
<p>Orbit is an agile package manager and extensible build tool for hardware description languages (HDL). Its design is driven by two core principles:</p>
<ul>
<li>minimize technical debt associated with evolving HDL codebases</li>
<li>tailor to the wide range of users and their possible workflows with a high degree of modularity and extensibility</li>
</ul>
<p>Orbit's use case is targeted toward anyone interested in developing digital hardware; this includes industrial, academic, and personal settings. Create your next commerical product, university lab assignment, or personal project, using a tool that is tailored to today's advanced development processes.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>This "book" is loosely divided into 4 sections:</p>
<ol>
<li><a href="./tutorials/tutorials.html">Tutorials</a> - Step-by-step lessons working with Orbit</li>
<li><a href="./user/user.html">User Guide</a> - General procedures for "how-to" solve common problems</li>
<li><a href="./topic/topic.html">Topic Guide</a> - Explanations that clarify and provide more detail to particular topics</li>
<li><a href="./reference/reference.html">Reference</a> - Technical information</li>
</ol>
<h2 id="about-the-project"><a class="header" href="#about-the-project">About the Project</a></h2>
<p>Orbit is available free to use and open source to encourage adoption, contribution, and integration among the hardware community. We rely on the open source community for feedback and new ideas, while remaining focused on our design goals and principles.</p>
<p>The project is currently open-source under the GPL-3.0 license and is available on <a href="https://github.com/chaseruskin/orbit">GitHub</a>.</p>
<h2 id="about-the-documentation"><a class="header" href="#about-the-documentation">About the Documentation</a></h2>
<p>The documentation system and methodology adopted by Orbit is inspired by <a href="https://documentation.divio.com">Divio</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section walks you the basic steps to get Orbit up and running on your local computer.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>Throughout the tutorials and the rest of the book, commands will be shown that are used in the terminal. Lines that are entered in a terminal are denoted by starting with a $. The $ is just a special marker; it is not to be entered with the command. Lines that don't start with a $ are typically the output of the previous command.</p>
</blockquote>
<p>There are two processes to obtaining and maintaining Orbit:</p>
<ol>
<li><a href="starting/./installing.html">Installing</a></li>
<li><a href="starting/./upgrading.html">Upgrading</a></li>
</ol>
<h2 id="seeking-help"><a class="header" href="#seeking-help">Seeking Help</a></h2>
<p>Orbit is a package manager and development tool. With learning new tools there is always a learning curve. Orbit tries to make it less intimidating to use by offering help and information in a variety of ways:</p>
<ul>
<li>To see a list of common commands and options, just use <code>orbit</code> with no arguments.</li>
<li>To view quick summaries on commands, use <code>-h, --help</code> flags.</li>
<li>To view more detailed manual pages and information, use <code>orbit help</code>.</li>
</ul>
<p>But since you are here, complete documentation can be found on this website.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>If you work in the realm of computers, you may hear the phrase: "<em>Hardware is hard</em>." But have you ever thought about <strong>why</strong>?</p>
<p>There are many possible answers that may lead to this phrase's existence, such as hardware involves battling real-world physics, or that hardware requires knowledge across a wide range of skills, or that hardware has infinitely many ways to go wrong. However, we decide to focus on one particular reason that arises in the context of digital hardware: <strong>a slow and expensive development cycle</strong>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>To describe hardware today, you typically use a hardware description language (HDL). The two most promiment HDLs used and supported by electronic design automation (EDA) tools are VHDL and Verilog. HDLs are not software programing languages, but rather a language to describe how a circuit is intended to be structured or function.</p>
<p>The core similarity between describing digital hardware and writing software programs is that the developer must apply the creative process by editing files called <em>source code</em>. Source code is used as an input to a back end process, whether it be compilation, simulation, or synthesis. Software and hardware encounter similar problems when working with source code, although software arguably has better tools that already do a good job in solving some of their problems.</p>
<p>Let's talk about some observations about source code development in the layer above hardware: software. Software development today not only has nice languages to develop with, but the entire ecosystem surrounding that language is a pleasant experience. Take the Rust programming language as an example. Not only does Rust have moden language constructs that forces programmers to rethink how to write their program in a safer way regarding computer memory, but the infrastructure surrounding Rust is very accessible and easy to use, which involves the compiler, code management, and code testing. This is great for software development, but does the same hold true for hardware development?</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>At the hardware layer, life is unfortunately not so simple. Not only are the promiment languages being used for things outside of their original intention, but the surrounding infrastructure around these languages is very lacking. Proprietary and expensive tools force developers to adapt to non-standardized practices, making it difficult to share code across systems or other tools, leading to the introduction of the concept called <em>vendor lock-in</em>. Vendor lock-in fragments the community and makes it increasingly difficult to find portable and easily usable source code. Hardware does not have as big of a footprint in the open-source world in comparison to software's vibrant open-source community.</p>
<p>Without the right infrastructure and tools to easily share, reuse, and maintain source code, hardware experiences slow and expensive development cycles. At this point, you be wondering what are the right tools and infrastructure that hardware needs? To answer this question, you may have to shift your perspective about hardware. Thinking of hardware with the waterfall approach of being <em>built and done with</em> is the wrong mindset. Hardware is rarely built once and forgotten about. Instead, one must think of hardware with a more agile approach in that it evolves and improves upon many iterations. This concept of hardware evolving over time requires special attention when creating the supportive infrastructure around it. But this infrastructure and tooling does not exist for the common HDL languages such as VHDL and Verilog.</p>
<p>Without the right infrastructure and tools, many source code maintenance tasks related to development, also known as <em>technical debt</em>, become exponentially more time-consuming and increasingly difficult as time goes on and the code base grows in size and complexity. The technical debt falls upon the developer to manually handle because there is no automated systematic tool to instead handle it. Large technical debt in turn leads to long and expensive hardware development cycles, and therefore it is a common goal to strive to minimize technical debt. The solution at this point is not to continue down the dark path ahead, but instead to take a look at how software managed to minimize this problem: package management.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The solution</a></h2>
<p>With the right tools, hardware development can experience faster development cycles and lower development costs. A tool that can make this experience true is a <em>package manager</em>. A package manager's role is to organize and automate the tasks related to source code management. A well-designed package manager can minimize technical debt, while a poorly-designed package manager simply shifts the technical debt to possibly new and different tasks. Software programming languages have become increasingly good at handling source code management through the creation of their own package managers, such as go mod for Go, Cargo for Rust, and pip for Python.</p>
<blockquote>
<p>Having well-designed and easily accessible tools is important to any form of development. Creativity's greatest limiting factor is the tools of which are available to turn an idea into a reality.</p>
</blockquote>
<p><em>Orbit</em> is an agile package manager for HDLs. It automates the process of organizing, maintaining, and reusing HDL source code across projects. Since it regularly interacts with the developer, it is designed to be simple and intuitive to use while highly tolerant against errors. Given the HDL landscape is fragmented and requires various EDA tools to carry out different tasks, Orbit is highly flexible- developers can setup their own targets with minimal effort to execute whatever EDA tool they prefer. Orbit operates as the intermediary between the developer's HDL source code and their EDA tools.</p>
<p>One of the major goals behind Orbit is to support the developer in shifting their perspective of hardware toward a more agile approach in being something that lives and evolves over time. By using Orbit as an HDL package manager, hardware development becomes an enjoyable experience with more of the developer's time devoted to <em>actually</em> creating cool things, not racking up technical debt and fighting to manage millions of files. After all, the saying should be "<em>Hardware is cool</em>", right?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing"><a class="header" href="#installing">Installing</a></h1>
<p>There are two main methods for getting Orbit running on your computer: downloading a precompiled binary or by using Cargo.</p>
<blockquote>
<p><strong>Reminder:</strong> By installing and using Orbit, you accept usage under its GPL-3.0 license.</p>
</blockquote>
<h2 id="1-using-a-precompiled-binary"><a class="header" href="#1-using-a-precompiled-binary">1. Using a precompiled binary</a></h2>
<ol>
<li>Visit Orbit's <a href="https://github.com/chaseruskin/orbit/releases">releases</a> page on Github to find all of its official releases.</li>
<li>Download the binary for your computer's architecture and operating system.</li>
<li>Install Orbit. Either run the provided <code>install</code> executable or follow the manual instructions for placing Orbit's executable (<code>orbit</code> for Unix and <code>orbit.exe</code> for Windows) in a location recognized by the PATH environment variable.</li>
</ol>
<p>There are multiple solutions to accomplish step 3. The following outlines one way to manually install Orbit depending on the user's operating system.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ol>
<li>Download the latest prebuilt package.</li>
</ol>
<pre><code>curl -LO https://github.com/chaseruskin/orbit/releases/download/0.23.2/orbit-0.23.2-x86_64-unknown-linux-musl.tar.gz
</code></pre>
<ol start="2">
<li>Extract the prebuilt package.</li>
</ol>
<pre><code>tar -xf orbit-0.23.2-x86_64-unknown-linux-musl.tar.gz -C orbit-0.23.2
</code></pre>
<ol start="3">
<li>Move the executable to a location already set in the PATH environment variable.</li>
</ol>
<pre><code>mv ./orbit-0.23.2/bin/orbit /usr/local/bin/orbit
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<ol>
<li>Download the latest prebuilt package.</li>
</ol>
<pre><code>curl -LO https://github.com/chaseruskin/orbit/releases/download/0.23.2/orbit-0.23.2-x86_64-apple-darwin.tar.gz
</code></pre>
<ol start="2">
<li>Extract the prebuilt package.</li>
</ol>
<pre><code>tar -xf orbit-0.23.2-x86_64-apple-darwin.tar.gz -C orbit-0.23.2
</code></pre>
<ol start="3">
<li>Move the executable to a location already set in the PATH environment variable.</li>
</ol>
<pre><code>mv ./orbit-0.23.2/bin/orbit /usr/local/bin/orbit
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ol>
<li>
<p>Open a new terminal (Powershell) to where Orbit was downloaded.</p>
</li>
<li>
<p>Unzip the prebuilt package.</p>
</li>
</ol>
<pre><code>$ expand-archive "./orbit-0.23.2-x86_64-windows.zip" -DestinationPath "orbit-0.23.2"
</code></pre>
<ol start="3">
<li>Make a new directory to store this package.</li>
</ol>
<pre><code>$ new-item -path "$env:LOCALAPPDATA/Programs/orbit" -itemtype directory
</code></pre>
<ol start="4">
<li>Move the package to the new directory.</li>
</ol>
<pre><code>$ copy-item "./orbit-0.23.2/*" -destination "$env:LOCALAPPDATA/Programs/orbit" -recurse
</code></pre>
<ol start="5">
<li>Edit the user-level PATH environment variable in <em><strong>Control Panel</strong></em> by adding <strong>%LOCALAPPDATA%\Programs\orbit\bin</strong>.</li>
</ol>
<h2 id="2-installing-with-cargo"><a class="header" href="#2-installing-with-cargo">2. Installing with Cargo</a></h2>
<p>To install the latest version through Cargo:</p>
<pre><code>$ cargo install --git https://github.com/chaseruskin/orbit.git --bin orbit --tag 0.23.2
</code></pre>
<p>This will build the <code>orbit</code> binary and place it a path already set in the PATH environment variable.</p>
<h2 id="checking-if-orbit-is-installed-correctly"><a class="header" href="#checking-if-orbit-is-installed-correctly">Checking if Orbit is installed correctly</a></h2>
<p>To verify Orbit is working correctly on your system, let's open a new terminal session and print it's current version.</p>
<pre><code>$ orbit --version
</code></pre>
<pre><code>orbit 0.23.2
</code></pre>
<p>This should print out your version of Orbit you installed.</p>
<p>You can also review the license for Orbit:</p>
<pre><code>$ orbit --license
</code></pre>
<pre><code>Copyright (C) 2022 - 2025 Chase Ruskin

This program is free software, covered by the GNU General Public License. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
</code></pre>
<p>Congratulations! You are now ready to begin using Orbit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading"><a class="header" href="#upgrading">Upgrading</a></h1>
<p>Once Orbit is installed, it can be self-upgraded to the latest official released version found on its Github repository.</p>
<pre><code>$ orbit --upgrade
</code></pre>
<p>This behavior performs the following strategy:</p>
<ol>
<li>
<p>Removes any executable in the executable's directory starting with <code>orbit-</code> (these are considered stale binaries, such as <code>orbit-0.1.0</code>).</p>
</li>
<li>
<p>Connects to <a href="https://github.com/chaseruskin/orbit/releases">https://github.com/chaseruskin/orbit/releases</a> to find the most recent released version.</p>
</li>
<li>
<p>Checks if the most recent version online is ahead of the currently installed version.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If the version online is newer, a prompt will appear to confirm you wish to install the new version. This prompt can be bypassed by adding the <code>--force</code> flag to the previous command.</p>
</blockquote>
<ol start="4">
<li>
<p>Downloads the checksum file to a temporary directory to see if there is a prebuilt package available for the current architecture and operating system.</p>
</li>
<li>
<p>Downloads the package to a temporary directory and computes the checksum to verify the contents.</p>
</li>
<li>
<p>Renames the current executable by appending its version to the name (marking it as a stale binary, such as <code>orbit-0.1.1</code>).</p>
</li>
<li>
<p>Unzips the package and moves the new executable to the original executable's location.</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: If you wish to remove the newly created stale binary after an upgrade, rerunning <code>orbit --upgrade</code> immediately again will perform step 1 and stop at step 3.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>This section provides step-by-step instructions through examples of basic ways for interacting with <code>orbit</code>.</p>
<blockquote>
<h3 id="command-line-notation-1"><a class="header" href="#command-line-notation-1">Command Line Notation</a></h3>
<p>Throughout the tutorials and the rest of the book, commands will be shown that are used in the terminal. Lines that are entered in a terminal are denoted by starting with a $. The $ is just a special marker; it is not to be entered with the command. Lines that don't start with a $ are typically the output of the previous command.</p>
</blockquote>
<p>Before starting the tutorials, it is assumed you possess basic knowledge of the following topics:</p>
<ul>
<li>sending commands through the command-line</li>
<li>digital logic concepts</li>
<li>navigating your computer's local file system</li>
</ul>
<br>
<blockquote>
<p><strong>Note:</strong> The HDL code used for this section may be very didactic in nature and is not intended to reflect production-level code or any particular coding style.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-project-gates"><a class="header" href="#first-project-gates">First Project: Gates</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/first_project.html#creating-an-ip">1.</a> Create an ip from scratch<br />
<a href="tutorials/first_project.html#integrating-design-units">2.</a> Use Orbit to integrate an entity into a larger design<br />
<a href="tutorials/first_project.html#building-an-ip-for-a-scripted-workflow">3.</a> Build a design using a simple target<br />
<a href="tutorials/first_project.html#making-an-ip-and-its-design-units-reusable">4.</a> Release a version of an ip</p>
<h2 id="creating-an-ip"><a class="header" href="#creating-an-ip">Creating an ip</a></h2>
<p>First, navigate to a directory in your file system where you would like to store the project. From there, let's issue our first <code>orbit</code> command:</p>
<pre><code>$ orbit new gates
</code></pre>
<p>A directory called "gates" should now exist and look like the following tree structure:</p>
<pre><code>gates/
├─ Orbit.lock
└─ Orbit.toml
</code></pre>
<p>Let's create our first design unit for describing a NAND gate. Feel free to copy the following code into a file called "nand_gate.vhd" that exists in our project directory "/gates".</p>
<p>Filename: nand_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity nand_gate is
  port(
    a, b : in std_logic;
    x : out std_logic
  );
end entity;

architecture rtl of nand_gate is
begin

  x &lt;= a nand b;

end architecture;
</code></pre>
<h2 id="integrating-design-units"><a class="header" href="#integrating-design-units">Integrating design units</a></h2>
<p>Consider for an instant that our HDL only supports the <code>nand</code> keyword and is missing the other logic gates such as <code>or</code>, <code>and</code>, and <code>xor</code>.</p>
<p>Recalling our basic knowledge of digital circuits, we know a NAND gate is a universal gate, so let's compose other gates using our newly created <code>nand_gate</code> entity. Create a new file for our next design unit to describe an AND gate.</p>
<p>Filename: and_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity and_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of and_gate is
begin

    -- What to put here?

end architecture;
</code></pre>
<p>After some thinking, we realize we can use two NAND gates together to construct an AND gate. Let's use Orbit to help us integrate our <code>nand_gate</code> entity into the <code>and_gate</code>'s architecture.</p>
<pre><code>$ orbit get nand_gate --component --signals --instance
</code></pre>
<pre><code>component nand_gate
  port(
    a : in std_logic;
    b : in std_logic;
    x : out std_logic
  );
end component;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>With this single command, Orbit provided us with:</p>
<ul>
<li>the component declaration</li>
<li>signals for the port interface</li>
<li>an instantiation template</li>
</ul>
<p>Sweet! After some quick copy/pasting and signal renaming, we have our architecture described for an AND gate.</p>
<p>Filename: and_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

entity and_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of and_gate is
  
  component nand_gate
    port(
      a : in std_logic;
      b : in std_logic;
      x : out std_logic
    );
  end component;

  signal x : std_logic;

begin

  u1 : nand_gate
    port map(
      a =&gt; a,
      b =&gt; b,
      x =&gt; x
    );

  u2 : nand_gate
    port map(
      a =&gt; x,
      b =&gt; x,
      x =&gt; y
    );

end architecture;
</code></pre>
<p>Let's make a quick check to verify our <code>and_gate</code> is using our <code>nand_gate</code>.</p>
<pre><code>$ orbit tree
</code></pre>
<pre><code>and_gate
└─ nand_gate
</code></pre>
<p>Cool! We got a hierarchical view of our top-most design unit.</p>
<h2 id="building-an-ip-for-a-scripted-workflow"><a class="header" href="#building-an-ip-for-a-scripted-workflow">Building an ip for a scripted workflow</a></h2>
<p>After all of our hard work, we are excited to show off our latest design on the newest Yilinx FPGA that just arrived in the mail. You realize you need a way to get your HDL code to the Yilinx synthesis tool in order to generate the final bitstream for your FPGA.</p>
<p>To make this possible, Orbit builds a project through two stages: planning and execution. Although both stages occur together, users must define their own targets to be invoked during execution. This explicit separation of layers between planning and execution enable the user to tailor the build process to their specific requirements.</p>
<h3 id="creating-a-target"><a class="header" href="#creating-a-target">Creating a target</a></h3>
<p>A target is a command invoked by Orbit for execution during the build process. In this example, we will write a script and have our target's command call our script to execute our process. In other words, you could say we are <em>targeting</em> the Yilinx tool. Let's make a simple target for our Yilinx synthesis tool using the Python programming language.</p>
<p>Filename: .orbit/yilinx.py</p>
<pre><code class="language-python">file_order = []
# Read and parse the blueprint file
with open('blueprint.tsv') as blueprint:
    rules = blueprint.readlines()
    for r in rules:
        fileset, lib, path = r.strip().split('\t')
        if fileset == 'VHDL':
            file_order += [(lib, path)]
    pass

# Use the Yilinx tool to perform synthesize on the HDL files
for (lib, path) in file_order:
    print('YILINX:', 'Synthesizing file ' + str(path) +' into ' + str(lib) + '...')

# Use the Yilinx tool to perform placement and routing
print('YILINX:','Performing place-and-route...')

# Use the Yilinx tool to generate the bitstream
print('YILINX:', 'Generating bitstream...')
with open('fpga.bit', 'w') as bitstream:
    bitstream.write('011010101101' * 2)

print('YILINX:','Bitstream saved at: target/yilinx/fpga.bit')

</code></pre>
<p>For Orbit to know about our target, we need to give information to Orbit about the target. This is done in a configuration file. For this example, we edit the project-level configurations.</p>
<p>Filename: .orbit/config.toml</p>
<pre><code class="language-toml">[[target]]
name = "yilinx"
description = "Generate bitstreams for Yilinx FPGAs"
command = "python"
args = ["yilinx.py"]
</code></pre>
<h3 id="calling-a-target"><a class="header" href="#calling-a-target">Calling a target</a></h3>
<pre><code>$ orbit build --target yilinx
</code></pre>
<pre><code>YILINX: Synthesizing file /Users/chase/tutorials/gates/nand_gate.vhd into gates...
YILINX: Synthesizing file /Users/chase/tutorials/gates/and_gate.vhd into gates...
YILINX: Performing place-and-route...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: target/yilinx/fpga.bit
</code></pre>
<p>Typically, we create targets to interface with EDA tools which will in turn produce desired output files, called artifacts. We see Yilinx saved our bitstream artifact for us to program our FPGA. Cool!</p>
<p>Filename: target/yilinx/fpga.bit</p>
<pre><code class="language-text">011010101101011010101101
</code></pre>
<h2 id="making-an-ip-and-its-design-units-reusable"><a class="header" href="#making-an-ip-and-its-design-units-reusable">Making an ip and its design units reusable</a></h2>
<p>Now we are ready to move on to more advanced topics, so let's go ahead and store an immutable reference to this project to use in other projects in our developer journey.</p>
<pre><code>$ orbit install
</code></pre>
<p>This command ran a series of steps that packaged our project and placed it into our <em>cache</em>. Internally, Orbit knows where our cache is and can reference designs from our cache when we request them. Let's make sure our project was properly installed by viewing our entire ip catalog.</p>
<pre><code>$ orbit search
</code></pre>
<pre><code>gates                       0.1.0       install
</code></pre>
<p>And there it is! Let's continue to the next tutorial, where we introduce dependencies across ips.</p>
<h3 id="additional-notes-on-project-structure"><a class="header" href="#additional-notes-on-project-structure">Additional notes on project structure</a></h3>
<p>Our final project structure looks like the following:</p>
<pre><code>gates/
├─ .orbit/
│  ├─ config.toml
│  └─ yilinx.py
├─ target/
│  ├─ CACHEDIR.TAG
|  └─ yilinx/
│     ├─ .env
│     ├─ blueprint.tsv
│     └─ fpga.bit
├─ Orbit.toml
├─ Orbit.lock
├─ and_gate.vhd
└─ nand_gate.vhd
</code></pre>
<ul>
<li>
<p>The configurations stored in "/.orbit" exist only for this project; to store configurations that persist across projects make changes to the $ORBIT_HOME directory.</p>
</li>
<li>
<p>Orbit creates an output directory to store the blueprint and any tool output files during a build. These files should reside in "/target" and may change often during development (probably don't check this directory into version control).</p>
</li>
<li>
<p>Orbit creates a lock file "Orbit.lock" to store all the information required to manage and recreate the exact state of this project. It is a good idea to always keep it and to not manually edit it (probably be sure to check this file into version control).</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies-half-adder"><a class="header" href="#dependencies-half-adder">Dependencies: Half adder</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/dependencies.html#referencing-external-ips">1.</a> Specify an external ip as a dependency<br />
<a href="tutorials/dependencies.html#learning-about-ips">2.</a> Use Orbit to learn more about external ips and their design units<br />
<a href="tutorials/dependencies.html#integrating-design-units-across-ips">3.</a> Leverage Orbit across ips to integrate an entity into a separate ip</p>
<h2 id="referencing-external-ips"><a class="header" href="#referencing-external-ips">Referencing external ips</a></h2>
<p>After completing the gates project from the previous tutorial ahead of schedule, you take a well deserved vacation. Now you have returned to work and are tasked with building a half adder.</p>
<p>Let's create a new project. Navigate to a directory in your file system where you would like to store the project.</p>
<pre><code>$ orbit new half-add --lib adding
</code></pre>
<p>For the rest of this tutorial, we will be working relative to the project directory "/half-add" that was created by the previous command.</p>
<p>Remembering our impressive work with the gates project, we realize we can reuse some of the already designed and tested components from there. Let's make sure it's installed so that we can use it.</p>
<pre><code>$ orbit search gates
</code></pre>
<pre><code>gates                       0.1.0       install
</code></pre>
<p>Awesome! Our next step is tell Orbit that our current project, half-add, wants to use gates as a dependency.</p>
<p>Add a new entry for gates to the dependencies table in our project's manifest, Orbit.toml.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "half-add"
library = "adding"
version = "0.1.0"

# See more keys and their definitions at https://chaseruskin.github.io/orbit/reference/manifest.html

[dependencies]
gates = "0.1.0"
</code></pre>
<p>We've referenced it, now we have to use it!</p>
<h2 id="learning-about-ips"><a class="header" href="#learning-about-ips">Learning about ips</a></h2>
<p>Your memory is a little foggy on what gates actually did, and what entities were available. Luckily, we can query for information through Orbit about ips and their design units.</p>
<p>Let's remember what entities we have at our disposal.</p>
<pre><code>$ orbit info gates --units
</code></pre>
<pre><code>and_gate                            entity        public 
nand_gate                           entity        public 
</code></pre>
<p>Okay, how did we implement the NAND gate architecture?</p>
<pre><code>$ orbit read --ip gates nand_gate --start architecture
</code></pre>
<pre><code>architecture rtl of nand_gate is
begin

  x &lt;= a nand b;

end architecture;
</code></pre>
<p>Cool, we had used the VHDL keyword <code>nand</code> to describe that particular circuit. Sometimes it may be insightful to read code snippets and comments from external design units when trying to integrate them into a new project.</p>
<h2 id="integrating-design-units-across-ips"><a class="header" href="#integrating-design-units-across-ips">Integrating design units across ips</a></h2>
<p>Let's use the NAND gate we previously defined to construct a half adder circuit.</p>
<pre><code>$ orbit get --ip gates nand_gate --library --signals --instance
</code></pre>
<pre><code>library gates;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : entity gates.nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>A half adder can be constructed with 5 NAND gates. It's time to copy/paste our NAND gate instances into our new file "half_add.vhd".</p>
<p>Filename: half_add.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library gates;

entity half_add is
  port(
    a, b : in std_logic;
    c, s : out std_logic
  );
end entity;

architecture rtl of half_add is
  
  signal x4, x1, x2 : std_logic;

begin

  -- 1st layer: This gate creates the first NAND intermediate output.
  u4 : entity gates.nand_gate
    port map(
      a =&gt; a,
      b =&gt; b,
      x =&gt; x4
    );
  
  -- 2nd layer: Perform NAND with input 'a' and the 1st layer's output.
  u1 : entity gates.nand_gate
    port map(
      a =&gt; a,
      b =&gt; x4,
      x =&gt; x1
    );

  -- 2nd layer: Perform NAND with input 'b' and the 1st layer's output.
  u2 : entity gates.nand_gate
    port map(
      a =&gt; x4,
      b =&gt; b,
      x =&gt; x2
    );

  -- 3rd layer: This gate produces the final sum signal ('a' XOR 'b').
  u3 : entity gates.nand_gate
    port map(
      a =&gt; x1,
      b =&gt; x2,
      x =&gt; s
    );

  -- 3rd layer: This gate produces the final carry out signal ('a' AND 'b').
  u5 : entity gates.nand_gate
    port map(
      a =&gt; x4,
      b =&gt; x4,
      x =&gt; c
    );

end architecture;
</code></pre>
<p>Let's inspect the design hierarchy to make sure our circuit and its components are identified by Orbit.</p>
<pre><code>$ orbit tree --format long
</code></pre>
<pre><code>half_add (half-add:0.1.0)
└─ nand_gate (gates:0.1.0)
</code></pre>
<p>Finally, let's install this ip to the cache for future reuse as well. But before we can install any ip to our cache, an ip must have an up to date lockfile.</p>
<p>Lockfiles are updated whenever a user calls <code>orbit build</code> or <code>orbit test</code>, but they can also be updated with the dedicated <code>orbit lock</code> command. Let's go ahead and generate the lockfile now.</p>
<pre><code>$ orbit lock
</code></pre>
<p>Now we can safely install the ip to our catalog.</p>
<pre><code>$ orbit install
</code></pre>
<p>Nice, now we have successfully reused designs across ips! However, maybe we should have designed all the logic gates in the gates ip...</p>
<h3 id="additional-notes-on-dependencies"><a class="header" href="#additional-notes-on-dependencies">Additional notes on dependencies</a></h3>
<p>Before integrating a design unit from an external ip into a separate project, it's important to first update the Orbit.toml file. This manifest file has a dependencies section, which allows you to tell Orbit which ips to bring into the current project scope. Without the ips in scope, Orbit may be unable to identify where you got a reference for a particular design unit. Orbit denotes an unknown design unit with a ? when displaying the design hierarchy.</p>
<pre><code>half_add (half-add:0.1.0)
└─ nand_gate ?
</code></pre>
<p>After introducing dependencies at the project level, it's also important to maintain an up-to-date lockfile, Orbit.lock. In most cases, Orbit will automatically generate it when it needs it, however, you as the user can also explicitly request Orbit to update the lockfile.</p>
<pre><code>$ orbit lock
</code></pre>
<p>The lockfile saves information for Orbit to use later when needing to reconstruct the state of an ip. This includes saving information about all ip dependencies, their checksums, and potential sources of retrieval. Remember, the Orbit.lock file is automatically managed by Orbit and does not require direct user editing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gates-revisited"><a class="header" href="#gates-revisited">Gates: Revisited</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/gates_revisited.html#updating-the-gates-ip">1.</a> Edit an existing ip<br />
<a href="tutorials/gates_revisited.html#extending-the-yilinx-target">2.</a> Use environment variables and command-line arguments to create more robust targets<br />
<a href="tutorials/gates_revisited.html#rereleasing-the-gates-ip">3.</a> Release the next version for an existing ip</p>
<h2 id="editing-the-gates-ip"><a class="header" href="#editing-the-gates-ip">Editing the gates ip</a></h2>
<p>It seems we left out some logic gates when we last worked on the gates project, so let's implement them now. Navigate to the directory in your file system where you currently store the gates project.</p>
<p>For the rest of this tutorial, we will be working relative to the project directory "/gates" that currently stores the gates project.</p>
<p>Let's implement the OR gate while restricting our design to only NAND gates like before.</p>
<pre><code>$ orbit get nand_gate --signals --instance
</code></pre>
<pre><code>library work;

signal a : std_logic;
signal b : std_logic;
signal x : std_logic;

uX : entity work.nand_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    x =&gt; x
  );
</code></pre>
<p>An OR gate can be constructed using 3 NAND gates. Let's copy/paste our NAND gate instances into our new file "or_gate.vhd".</p>
<p>Filename: or_gate.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library work;

entity or_gate is
  port(
    a, b : in std_logic;
    y : out std_logic
  );
end entity;

architecture rtl of or_gate is

  signal x1, x2 : std_logic;

begin
  -- 1st layer: This gate negates the first input 'a'.
  u1 : entity work.nand_gate
    port map(
      a =&gt; a,
      b =&gt; a,
      x =&gt; x1
    );

  -- 1st layer: This gate negates the second input 'b'.
  u2 : entity work.nand_gate
    port map(
      a =&gt; b,
      b =&gt; b,
      x =&gt; x2
    );
    
  -- 2nd layer: This gate produces the final output ('a' OR 'b').
  u3 : entity work.nand_gate
    port map(
      a =&gt; x1,
      b =&gt; x2,
      x =&gt; y
    );

end architecture;
</code></pre>
<p>Showing the list of possible design units for the current project should now include the OR gate entity.</p>
<pre><code>$ orbit info --units
</code></pre>
<pre><code>and_gate                            entity        public
nand_gate                           entity        public 
or_gate                             entity        public 
</code></pre>
<h2 id="extending-the-yilinx-target"><a class="header" href="#extending-the-yilinx-target">Extending the Yilinx target</a></h2>
<p>Next, we want to program our Yilinx FPGA with the OR gate design to test it on the board. However, there are some quick updates we first want to apply to the ".orbit/yilinx.py" script.</p>
<ul>
<li>We want a way to specify which I/O pins of the FPGA will be used during placement and routing</li>
<li>We want a way to specify whether to program the FPGA bitstream to SRAM storage (volatile) or flash storage (nonvolatile).</li>
</ul>
<p>After searching through Yilinx documentation for hours, you learn that the Yilinx design tool can accept .ydc files for FPGA pin assignments. Let's edit our yilinx target to collect any .ydc files our project may have during Orbit's planning step.</p>
<p>Filename: .orbit/config.toml</p>
<pre><code class="language-toml">[[target]]
name = "yilinx"
command = "python"
description = "Generate bitstreams for Yilinx FPGAs"
args = ["yilinx.py"]
# Define the type of extra file(s) to collect during planning
fileset.YDCF = "*.ydc"
</code></pre>
<p>Now let's create our pin assignment file for our OR gate design.</p>
<p>Filename: pins.ydc</p>
<pre><code class="language-text">A1=a
A2=b
C7=y
</code></pre>
<p>Next, let's edit the Python script for the yilinx target to allow the Yilinx tool to use our .ydc file if we ever collect one into our blueprint file. We also want to accept command-line arguments to optionally program our FPGA using SRAM or flash storage.</p>
<p>Filename: .orbit/yilinx.py</p>
<pre><code class="language-Python">import sys, os

# Handle command-line arguments
PROG_SRAM = bool(sys.argv.count('--sram') &gt; 0)
PROG_FLASH = bool(sys.argv.count('--flash') &gt; 0)

# Get environment variables set by orbit for this particular build
BLUEPRINT = os.environ.get("ORBIT_BLUEPRINT")
OUTPUT_PATH = os.environ.get("ORBIT_OUTPUT_PATH")
TOP_LEVEL = os.environ.get("ORBIT_TOP")

synth_order = []
constraints_file = None

# Parse the blueprint file created by orbit
with open(BLUEPRINT) as blueprint:
    rules = blueprint.readlines()
    for r in rules:
        fileset, lib, path = r.strip().split('\t')
        if fileset == 'VHDL':
            synth_order += [(lib, path)]
        if fileset == 'YDCF':
            constraints_file = path
    pass

# Run the Yilinx tool from synthesis to bistream generation
for (lib, path) in synth_order:
    print('YILINX:', 'Synthesizing file ' + str(path) + ' into ' + str(lib) + '...')

print('YILINX:','Performing place-and-route...')

# Read the Yilinx design constraints file to map pins to I/O top-level ports.
if constraints_file != None:
    with open(constraints_file, 'r') as ydc:
        mapping = [x.strip().split('=') for x in ydc.readlines()]
    for pin, port in mapping:
        print('YILINX:', 'Mapping pin ' + str(pin) + ' to port ' + str(port) + '...')
    pass

print('YILINX:', 'Generating bitstream...')

BIT_FILE = TOP_LEVEL + '.bit'
with open(BIT_FILE, 'w') as bitstream:
    for byte in [bin(b)[2:] for b in bytes(TOP_LEVEL, 'utf-8')]:
        bitstream.write(byte)

print('YILINX:','Bitstream saved at: '+ str(OUTPUT_PATH + '/' + BIT_FILE))

# Optionally allow the user to program the FPGA using flash or SRAM configuration
if PROG_FLASH == True and PROG_SRAM == False:
    print('YILINX:', 'Programming bitstream to flash...')
elif PROG_SRAM == True:
    print('YILINX:', 'Programming bitstream to SRAM...')
  
</code></pre>
<p>With all these changes, we can now go ahead and program our FPGA as we want!</p>
<p>To execute our latest changes to our Yilinx target build process, let's use <code>orbit build</code>. Recall that this command can be divided into two distinct stages: planning and execution. Planning is completed by Orbit once it generates a blueprint file. During planning, it looked at what files the target also requests under it's <code>fileset</code> TOML configuration.</p>
<pre><code>$ orbit build --target yilinx --top or_gate -- --flash
</code></pre>
<p>Let's take a look at the blueprint file Orbit created during the build process.</p>
<p>Filename: target/yilinx/blueprint.tsv</p>
<pre><code class="language-text">YDCF	gates	/Users/chase/tutorials/gates/pins.ydc
VHDL	gates	/Users/chase/tutorials/gates/nand_gate.vhd
VHDL	gates	/Users/chase/tutorials/gates/or_gate.vhd
</code></pre>
<p>Notice also how we passed a command-line argument <code>--flash</code>, to our target process for execution. Any arguments that are found after <code>--</code> are ignored by Orbit and sent directly to the targeted process.</p>
<p>Reviewing the output from our target's execution, we see that our FPGA was programmed successfully.</p>
<pre><code>YILINX: Synthesizing file /Users/chase/tutorials/gates/nand_gate.vhd into gates...
YILINX: Synthesizing file /Users/chase/tutorials/gates/or_gate.vhd into gates...
YILINX: Performing place-and-route...
YILINX: Mapping pin A1 to port a...
YILINX: Mapping pin A2 to port b...
YILINX: Mapping pin C7 to port y...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: target/or_gate.bit
YILINX: Programming bitstream to flash...
</code></pre>
<p>As expected, the bitstream is also written and saved within our target's output path.</p>
<p>Filename: target/yilinx/or_gate.bit</p>
<pre><code class="language-text">1101111111001010111111100111110000111101001100101
</code></pre>
<p>Awesome! We added some pretty advanced settings to our yilinx target to make it more robust for future use. Let's configure this target to be used with any of our ongoing projects by editing the global configuration file through the command-line.</p>
<pre><code>$ orbit config --global --append include="$(orbit env ORBIT_IP_PATH)/.orbit/config.toml"
</code></pre>
<p>Now when we call Orbit from any directory, we can see our yilinx target is available to use.</p>
<pre><code>$ orbit build --list
</code></pre>
<pre><code>yilinx          Generate bitstreams for Yilinx FPGAs
</code></pre>
<h2 id="rereleasing-the-gates-ip"><a class="header" href="#rereleasing-the-gates-ip">Rereleasing the gates ip</a></h2>
<p>We made changes to the gates ip, and now we want to have the ability to use these new updates or continue using the old changes. To do this, we want to update the version number in the manifest file. Let's edit the Orbit.toml file's version field to contain version "1.0.0".</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "gates"
version = "1.0.0"

# See more keys and their definitions at https://chaseruskin.github.io/orbit/reference/manifest.html

[dependencies]

</code></pre>
<p>Finally, let's release version 1.0.0 for the gates ip by installing it to our cache.</p>
<pre><code>$ orbit install
</code></pre>
<p>One last look at the catalog shows the latest version of gates we have installed is indeed 1.0.0. Nice work!</p>
<pre><code>$ orbit search gates
</code></pre>
<pre><code>gates                       1.0.0     install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-full-adder"><a class="header" href="#final-project-full-adder">Final Project: Full adder</a></h1>
<p>In this tutorial, you will learn how to:</p>
<p><a href="tutorials/final_project.html#specifying-multiple-dependencies-for-an-ip">1.</a> Depend on multiple ips for a single project<br />
<a href="tutorials/final_project.html#overcoming-hdl-problems-namespace-pollution">2.</a> Use Orbit to overcome namespace pollution<br />
<a href="tutorials/final_project.html#reusing-targets-that-are-globally-configured">3.</a> Build a project with a globally-configured target</p>
<h2 id="specifying-multiple-dependencies-for-an-ip"><a class="header" href="#specifying-multiple-dependencies-for-an-ip">Specifying multiple dependencies for an ip</a></h2>
<p>After the quick detour back to the gates ip, we are ready to tackle our final challenge in this mini tutorial series: the full adder. Like our previous projects, navigate to a directory in your file system where you would like to store the project.</p>
<pre><code>orbit new full-add --lib adding
</code></pre>
<p>For the rest of this tutorial, we will be working relative to the project directory "/full-add" that currently stores our new full-add project.</p>
<p>For this final project, we will need circuits described in both the gate ip and half-add ip. Let's quickly recall if version 1.0.0 of gates has the OR gate we will need.</p>
<pre><code>$ orbit info gates:1.0.0 --units
</code></pre>
<pre><code>and_gate                            entity        public 
nand_gate                           entity        public 
or_gate                             entity        public 
</code></pre>
<p>Yup! It's there, and we know we will need some half adders as well. Let's add both ips to our manifest file.</p>
<p>filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "full-add"
library = "adding"
version = "0.1.0"

# See more keys and their definitions at https://chaseruskin.github.io/orbit/reference/manifest.html

[dependencies]
gates = "1.0.0"
half-add = "0.1.0"

</code></pre>
<p>Okay, time to start coding!</p>
<h2 id="overcoming-hdl-problems-namespace-pollution"><a class="header" href="#overcoming-hdl-problems-namespace-pollution">Overcoming HDL problems: Namespace pollution</a></h2>
<p>Our full adder circuit will be constructed of 2 half adders and an OR gate. Let's collect some HDL code snippets to use for our full adder circuit.</p>
<pre><code>$ orbit get half_add --ip half-add --library --instance
</code></pre>
<pre><code>library adding;

uX : entity adding.half_add
  port map(
    a =&gt; a,
    b =&gt; b,
    c =&gt; c,
    s =&gt; s
  );
</code></pre>
<p>And let's get the code snippet for the OR gate as well.</p>
<pre><code>$ orbit get or_gate --ip gates:1.0.0 --library --instance
</code></pre>
<pre><code>library gates;

uX : entity gates.or_gate
  port map(
    a =&gt; a,
    b =&gt; b,
    y =&gt; y
  );
</code></pre>
<p>Let's combine these circuits together into our new file for our full adder implementation.</p>
<p>Filename: full_add.vhd</p>
<pre><code class="language-vhdl">library ieee;
use ieee.std_logic_1164.all;

library adding;
library gates;

entity full_add is
  port(
    a, b, cin : in std_logic;
    cout, s : out std_logic
  );
end entity;

architecture rtl of full_add is
  
  signal c_ha0, s_ha0, c_ha1 : std_logic;

begin

  -- 1st layer: Peform half of the addition operation.
  u_ha0 : entity adding.half_add
    port map(
      a =&gt; a,
      b =&gt; b,
      c =&gt; c_ha0,
      s =&gt; s_ha0
    );

  -- 2nd layer: Compute the final sum term.
  u_ha1 : entity adding.half_add
    port map(
      a =&gt; s_ha0,
      b =&gt; cin,
      c =&gt; c_ha1,
      s =&gt; s
    );

  -- 3rd layer: Check both c terms from the half adders for the final cout term.
  u_or0 : entity gates.or_gate
    port map(
      a =&gt; c_ha0,
      b =&gt; c_ha1,
      y =&gt; cout
    );

end architecture;
</code></pre>
<p>Our design heirarchy is getting more complex; we have full adders constructed of half adders and OR gates, half adders constructed of NAND gates, OR gates constructed of... uh-oh. More NAND gates.</p>
<p>The NAND gate design unit used in the OR gates is different from NAND gates used in the half adders because they reside in different versions of the gates ip (essentially different ips). So did we just define an NAND gate entity twice with the same identifier? Yes, and thanks to Orbit, this situation is okay.</p>
<h3 id="huh"><a class="header" href="#huh">Huh?</a></h3>
<p>Typical EDA tools will complain and error out when primary design units share the same name. How would they know which one is being used where? Fortunately, Orbit is one step ahead of these tools due to implementing an algorithm called <em>dynamic symbol transformation</em>.</p>
<p>Let's take a look at the design tree hierarchy. You may notice something interesting.</p>
<pre><code>$ orbit tree --format long
</code></pre>
<pre><code>full_add (full-add:0.1.0)
├─ or_gate (gates:1.0.0)
│  └─ nand_gate (gates:1.0.0)
└─ half_add (half-add:0.1.0)
   └─ nand_gate_56ade36a78 (gates:0.1.0)
</code></pre>
<p>The entities from gates version 0.1.0 and version 1.0.0 are allowed to co-exist in this design. To circumvent EDA tool problems during builds, Orbit appends the beginning checksum digits from the ip of the unit in conflict to the design unit's identifier. Any design units that referenced the unit in conflict will also be updated to properly reference the new identifier for the unit in conflict.</p>
<p>To us though, these slight identifier renamings remain hidden because they occur among indirect dependencies in relation to our current project. When deciding which design unit to rename, Orbit will always choose to rename the unit that is used as an indirect dependency. This key choice allows us to keep using the original unit name when integrating design units into the current project.</p>
<h3 id="okay-so-what"><a class="header" href="#okay-so-what">Okay, so what?</a></h3>
<p>This may be a silly example, but there is a key takeaway here. Designs are constantly evolving. When creating the latest module, you never know what will come next. By allowing the state of a design to live on while also providing support for new growth, a user no longer spends their time trying to manage compatibility among the increasingly interconnected dependencies. Instead, there exists a freedom to continue to innovate.</p>
<h2 id="reusing-targets-that-are-globally-configured"><a class="header" href="#reusing-targets-that-are-globally-configured">Reusing targets that are globally-configured</a></h2>
<p>To conclude this mini tutorial series, let's generate a bitstream for the Yilinx FPGA with our full adder implementation.</p>
<p>First, let's verify our yilinx target is available to us after appending it to our global configuration file in the previous tutorial.</p>
<pre><code>$ orbit build --list
</code></pre>
<pre><code>yilinx          Generate bitstreams for Yilinx FPGAs
</code></pre>
<p>We can review more details about a particular target by specifying it with the "--target" command-line option while providing "--list" as well.</p>
<pre><code>$ orbit build --list --target yilinx
</code></pre>
<pre><code>Name:    yilinx
Command: python "yilinx.py" 
Root:    /Users/chase/tutorials/gates/.orbit
Filesets:
    PIN-FILE        **/*.ydc

Generate bitstreams for Yilinx FPGAs
</code></pre>
<p>Let's build our current project using the yilinx target for our full adder.</p>
<pre><code>$ orbit build --target yilinx --top full_add
</code></pre>
<p>Opening the blueprint file created by Orbit during the planning stage shows we are indeed using different files for the different NAND gate design units, and the files are in a topologically-sorted order.</p>
<p>Filename: target/yilinx/blueprint.tsv</p>
<pre><code class="language-text">VHDL	gates	/Users/chase/.orbit/cache/gates-0.1.0-fe9ec9d99e/nand_gate.vhd
VHDL	adding	/Users/chase/.orbit/cache/half-add-0.1.0-1c537df196/half_add.vhd
VHDL	gates	/Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/nand_gate.vhd
VHDL	gates	/Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/or_gate.vhd
VHDL	adding	/Users/chase/tutorials/full-add/full_add.vhd

</code></pre>
<p>Inspecting the output displayed to the console shows our target executed it's process successfully with the creation of a .bit file.</p>
<pre><code>YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-0.1.0-fe9ec9d99e/nand_gate.vhd into gates...
YILINX: Synthesizing file /Users/chase/.orbit/cache/half-add-0.1.0-1c537df196/half_add.vhd into adding...
YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/nand_gate.vhd into gates...
YILINX: Synthesizing file /Users/chase/.orbit/cache/gates-1.0.0-4cb065a539/or_gate.vhd into gates...
YILINX: Synthesizing file /Users/chase/tutorials/full-add/full_add.vhd into adding...
YILINX: Performing place-and-route...
YILINX: Generating bitstream...
YILINX: Bitstream saved at: target/yilinx/full_add.bit
</code></pre>
<p>Great work! This marks the end to this tutorial series, but the beginning of your experience with Orbit, an agile package manager and extensible build tool for HDLs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<p>This section provides general solutions to common questions when working with <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Orbit provides commands through the command-line interface to help at every stage in the hardware development cycle.</p>
<p><img src="user/./../images/process.svg" alt="" /></p>
<h2 id="hardware-development-cycle"><a class="header" href="#hardware-development-cycle">Hardware development cycle</a></h2>
<p>The hardware development cycle can be loosely divided into three main stages:</p>
<ol>
<li>
<p><strong>Research/Planning</strong>: Define a project's goals, scope, requirements, and identify any existing solutions that can be reused</p>
</li>
<li>
<p><strong>Design/Development</strong>: Create the architecture, implement the system's functionalities, and verify the design meets the requirements through testing</p>
</li>
<li>
<p><strong>Deployment/Maintenance</strong>: Release the project to the production environment to make it accessible to its users while providing ongoing updates, bug fixes, and new features over time</p>
</li>
</ol>
<h2 id="development-process"><a class="header" href="#development-process">Development process</a></h2>
<h3 id="1-research"><a class="header" href="#1-research">1. Research</a></h3>
<p>At the start of any project, it's important to survey existing work to identify any related projects that either already meet your requirements or can be used to help meet your requirements.</p>
<ul>
<li>
<p>Orbit helps you quickly survey what projects exist in the ip catalog with <code>orbit search</code>. This will return a list of all projects available in the ip catalog, their latest version, their status (installed, downloaded, available), and its unique identifier.</p>
</li>
<li>
<p>Further refining your search to get more information about a particular project can be done with <code>orbit info</code>. This command can display data pulled from the ip's manifest, what design units it contains, the different versions of the project, and other data related to that project.</p>
</li>
<li>
<p>After finding a design unit of interest within a particular project, a reference to that design unit's source code can be made available with <code>orbit read</code>. If the source code is well-documented and written in a clear manner, then this referring to the source code can help easily understand if using this particular design unit will be able to help you in your next project.</p>
</li>
</ul>
<blockquote>
<p><strong>Tip</strong>: The read operation works especially well with a command-line pager such as <code>less</code>, allowing the source code contents to be easily navigated by piping it as input to the pager.</p>
</blockquote>
<h3 id="2-development"><a class="header" href="#2-development">2. Development</a></h3>
<p>The bulk of time and resources for any project takes place during the development stage. In this stage, the project's architecture is created, the system's functionalities are implemented, and checked to make sure they meet the project's requirements through testing.</p>
<ul>
<li>
<p>Using any design units from existing ip in your latest project can be quickly achieved using <code>orbit get</code>. This command will return the necessary HDL code snippets to correctly instantiate a design unit. Simply adding the external ip's name and version to the current project's <code>[dependencies]</code> table within the <code>Orbit.toml</code> file will allow Orbit to record the information necessary to correctly reference the design unit's within that ip.</p>
</li>
<li>
<p>Running a build process on a new design unit that does not require a testbench can be achieved with <code>orbit build</code>. By configuring and specifying a target, this command gives you the power to run any particular workflow for your set of tools and unique demands, such as performing synthesis.</p>
</li>
<li>
<p>Running a build process to verify a new design unit with its accompanied testbench can be achieved with <code>orbit test</code>. This command requires the user to configure and specify a target similiar to <code>orbit build</code>, but under the intention that a testbench is required, perhaps for running a simulation.</p>
</li>
</ul>
<h3 id="3-deployment"><a class="header" href="#3-deployment">3. Deployment</a></h3>
<p>After a project has been successfully developed and meets its specified goals and requirements, it can be deployed to its production environment and made available to its users.</p>
<ul>
<li>
<p>A detailed record of how to reproduce the project using Orbit can created with <code>orbit lock</code>. This command will generate a lockfile, <code>Orbit.lock</code>, which saves all the information about the current project and its dependencies such that the exact state of the project can be reproduced at a later time in any environment.</p>
</li>
<li>
<p>Securing the current state of the project as a release (such as version 1.0.0) for others to find is done using <code>orbit publish</code>. This command verifies the current project's state is valid in the context of Orbit and then installs it to your local ip catalog as well as posts its manifest to any of its configured channels. By posting the ip to a channel, any other users who also have the same channel configured will be able to see the newly available project.</p>
</li>
</ul>
<p>And with that, the cycle continues. As new features, bug fixes, and improvements are brought forth over time, users can repeat the following process to produce another release for any given project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-ip"><a class="header" href="#managing-ip">Managing Ip</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="targeting-builds"><a class="header" href="#targeting-builds">Targeting Builds</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic-guide"><a class="header" href="#topic-guide">Topic Guide</a></h1>
<p>This section provides explanations and clarity to the various systems operated by <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Orbit is an agile package manager and extensible build tool for HDLs.</p>
<p><img src="topic/./../images/architecture2.svg" alt="" /></p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key concepts</a></h2>
<ul>
<li>
<p>Orbit manages your ips using a group of file system directories that together make up the <strong>Catalog</strong>. The catalog has 3 levels that store increasingly more information about a particular ip: <strong>Channels</strong>, the <strong>Archive</strong>, and the <strong>Cache</strong>.</p>
</li>
<li>
<p>An ip's manifest may be stored in a user-defined channel so that a user can find that ip. Running <code>orbit install</code> will download the ip from its defined source found in its channel and create a compressed snapshot of the ip in the archive. Once the compressed snapshot is saved, Orbit will decompress the archived snapshot into an immutable reference of the ip at the cache level. The usage of checksums prevents users from editing ips in the cache.</p>
</li>
<li>
<p>Every ip requires a <strong>Manifest</strong> file, named <code>Orbit.toml</code>. This is a simple TOML file maintained by the user. The manifest file documents basic metadata about the ip, like its name and version, as well as the ip's list of direct dependencies.</p>
</li>
<li>
<p>An ip saves its world state by storing a <strong>Lockfile</strong>, called <code>Orbit.lock</code>, alongside the manifest. A lockfile lists all of the resolved ip dependencies required for the local ip and how to retrieve those ips if necessary again. Running <code>orbit lock</code> will build an ip-level graph to resolve the entire ip-level dependency tree and store this information in the lockfile.</p>
</li>
<li>
<p>Users customize their experience with Orbit using <strong>Configurations</strong>, which collections of <strong>Targets</strong>, <strong>Settings</strong>, and <strong>Protocols</strong>. All of these items are defined in an Orbit configuration file, called <code>config.toml</code>. Configurations allow users to reuse and share their workflows across teams and ips.</p>
</li>
<li>
<p>To build (or test) a design within a local ip, Orbit runs a <strong>Build Process</strong>. The build process takes as input the local ip's <strong>Lockfile</strong>, <strong>Source Files</strong> (hdl code), <strong>Auxiliary Files</strong> (any other file types needed), and a specified <strong>Target</strong>. Running <code>orbit build</code> (or <code>orbit test</code>) will enter the build process.</p>
</li>
<li>
<p>The build process occurs in 2 stages: the <strong>Planning Stage</strong> and the <strong>Execution Stage</strong>. During the planning stage, Orbit generates a <strong>Blueprint</strong>, which is a single file that lists all the files required to perform the build. During the execution stage, Orbit calls the specified <strong>Target</strong>'s commmand, which typically reads the previously generated blueprint and processes the files using some user-defined EDA tool. The final output from the build process is typically one or more <strong>Artifacts</strong>, which are one or more files generated from the user-defined EDA tool.</p>
</li>
<li>
<p>Publish a new version of an ip when it is ready by posting it to a user-defined channel. This method enables other users who also have that channel configured to seamlessly discover and access that new version of the ip. Running <code>orbit publish</code> will run a series of checks and then copy the ip's manifest to the proper location within the specified channel.</p>
</li>
</ul>
<h2 id="other-notes"><a class="header" href="#other-notes">Other notes</a></h2>
<ul>
<li>
<p>Backend EDA tools and workflows (makefiles, TCL scripts, etc.) are decoupled from ip and are able to be reused across projects by creating targets in the configuration file (<code>config.toml</code>).</p>
</li>
<li>
<p>Orbit does not require a version control system (VCS). Orbit is intended to work with any VCS (git, mercurial, svn, etc.).</p>
</li>
<li>
<p>Orbit solves the namespace collision problem by a variant of name mangling when primary design unit identifiers conflict in the dependency tree (<em>dynamic symbol transformation</em>).</p>
</li>
<li>
<p>Orbit generates a lockfile (<code>Orbit.lock</code>) during the planning stage of the build process. The lockfile saves the entire state such that Orbit can return to this state at a later time or on a different computing system. All necessary data that is required to reproduce the build is stored in the lockfile. The lockfile is maintained by Orbit and should be checked into versionc control.</p>
</li>
<li>
<p>Orbit generates a blueprint during the planning stage of the build process. The blueprint is a single file that lists the HDL source code files required for the particular build in topologically sorted order. Targets can also specify other file types to be collected into the blueprint. The blueprint is an artifact to be consumed by the target's process during the exection stage of the build process. Since it can frequently change with each build, it should not be checked into version control.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agile-package-management"><a class="header" href="#agile-package-management">Agile Package Management</a></h1>
<p>Orbit is an agile package manager for HDLs. Orbit supports a wide range of commands to the user to automate codebase management processes for installing ip, referencing ip, and removing ip.</p>
<h2 id="installing-1"><a class="header" href="#installing-1">Installing</a></h2>
<p><code>orbit install</code></p>
<p>Before you can reference an ip in your current project, you must first make sure the ip exists on your local filesystem. Orbit manages ip through its <em>ip catalog</em>. The catalog consists of multiple file paths that Orbit maintains for ips at varying states of accessibility.</p>
<p>To make an ip accessible by another project, it must first be installed to your ip catalog.</p>
<h2 id="referencing"><a class="header" href="#referencing">Referencing</a></h2>
<p><code>orbit info</code>, <code>orbit get</code></p>
<p>Once an ip is installed to your ip catalog, the design units of that ip are available to be referenced in the current design.</p>
<ol>
<li>
<p>Tell Orbit which installed ip you wish to use by providing the name and version under the <code>[dependencies]</code> table in the Orbit.toml file.</p>
</li>
<li>
<p>Instantiate one of the available design units from the dependency in your source code. At this point, any build that uses this HDL source code will be correctly sorted during the planning stage in topological order.</p>
</li>
</ol>
<h2 id="removing"><a class="header" href="#removing">Removing</a></h2>
<p><code>orbit remove</code></p>
<p>An ip can be removed from the catalog when it is no longer supported or needed to be used again. By removing the ip, Orbit deletes the ip's contents stored in the catalog, effectively forgetting that it existed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensible-builds"><a class="header" href="#extensible-builds">Extensible Builds</a></h1>
<p>Orbit is an extensible build tool for HDLs. Orbit separates the build process into two stages: planning and execution. When the build process happens, both stages are operated together in sequential order. Orbit provides two entry points into the build process: <code>orbit test</code> and <code>orbit build</code>.</p>
<p>What makes Orbit extensible? Well, Orbit does not define the execution stage by default. It leaves it upon the user to add their own execution processes, called <em>targets</em>. A target can be added through modifying an Orbit configuration file.</p>
<p>Orbit leaves the execution stage undefined by default because there are a wide range of different backend EDA tools available that enforce different requirements and even change requirements and behaviors across versions. It would be a nightmare to try to design a "one-script-fits-all" approach because everyone's computing system and choice of tool is so diverse.</p>
<h2 id="test-or-build"><a class="header" href="#test-or-build">Test or build?</a></h2>
<p>Orbit provides two entry points into the build process: <code>orbit test</code> and <code>orbit build</code>. Each entry point is suited for a particular type of build process.</p>
<p>If you are trying to run a simulation (accompanied by an HDL testbench), then you should use the <code>orbit test</code> entry. This command allows you to enter the build process by specifying the testbench using <code>--tb &lt;unit&gt;</code> and its design-under-test using <code>--dut &lt;unit&gt;</code>. This entry is typically used for verification workflows, where the end result of the build process is more concerned about making sure all steps in the process complete successfully with no errors.</p>
<p>For any non-testing workflow (one that lacks an HDL testbench), then you should use the <code>orbit build</code> entry. This command allows you to enter the build process by specifying the top level using <code>--top &lt;unit&gt;</code>. This entry is typically used for any workflow where the end result of the build process is more concerned about producing output files (commonly called artifacts), such as a bitstream or synthesis report.</p>
<h2 id="planning"><a class="header" href="#planning">Planning</a></h2>
<p>During the planning stage, Orbit resolves all source code dependencies to generate a single file that lists all the necessary source files in topologically sorted order. This file that stores the ordered list of source file paths is called the <em>blueprint</em>.</p>
<p>Orbit sets runtime environment variables that can be accessed during the execution stage by the specified target.</p>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>The execution stage occurs after the planning stage. During the execution stage, Orbit invokes the specified target's command with its set of determined arguments. The arguments to include are taken from the predefined list in the configuration file as well as any additional arguments found on the command line that appear after an empty double switch (<code>--</code>).</p>
<p>Typically, the target's process involves reading the blueprint previously generated from the planning stage and performing some task to generate an <em>artifact</em>. An artifact is what the build produces at the end of its execution, which may be anything, from a synthesis report to a bitstream file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="catalog"><a class="header" href="#catalog">Catalog</a></h1>
<p>As a package manager, Orbit must know what ips are available and where ips are stored on your local file system so that they can be operated on. Orbit stores your ips in the <em>catalog</em>. The <em>catalog</em> is a set of directories on your local file system maintained by orbit. These directories are typically hidden from the user because they are not regularly interfacing with the file system contents at these locations and manually tampering the contents may cause trouble for Orbit when it tries to use them.</p>
<p>There are three levels to the catalog: the cache, the archive, and channels.</p>
<h2 id="cache"><a class="header" href="#cache">Cache</a></h2>
<p>The <em>cache</em> maintains the ips that are currently <em>installed</em> on your local file system. Installed ips can be immediately added as a dependency to your current project.</p>
<p>Default location: <code>$ORBIT_HOME/cache</code></p>
<h2 id="archive"><a class="header" href="#archive">Archive</a></h2>
<p>The <em>archive</em> maintains the ips that are currently <em>downloaded</em> on your local file system. Downloaded ips can be added as a dependency to your current project only after being installed to the cache.</p>
<p>Default location: <code>$ORBIT_HOME/archive</code></p>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p><em>Channels</em> are user-defined directories to set up as registries to maintain the ips that are currently <em>available</em> to download or install. These ips may require internet to download their contents and then install to your cache.</p>
<p>Default location: <code>$ORBIT_HOME/channels</code></p>
<p>Adding a new channel is as simple as adding a directory to the location where channels are defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ip"><a class="header" href="#ip">Ip</a></h1>
<p>Ips are the core component that Orbit operates on as a package manager. First, let's understand some key terms related to ip in the context of Orbit.</p>
<h2 id="anatomy-of-an-ip"><a class="header" href="#anatomy-of-an-ip">Anatomy of an ip</a></h2>
<p>A developer's tasks often involve interfacing with a collection of closely related files (source code, scripts, text files). This collection of closely related files is typically stored under a single directory and is called a <em>project</em>.</p>
<p>The core operations of a package manager revolve around <em>packages</em>. A <em>package</em> is a project <em>with additional information provided by the developer</em>. This "additional information" is called <em>metadata</em>, and it is written to a special file called a <em>manifest</em>. The manifest must be placed at the project's root directory. Without manifests, a package manager would not know which projects it should manage and what each project's current state is in regards to being a package.</p>
<p>In the context of being a package manager for digital hardware, Orbit calls a package an <em>ip</em>. An ip's manifest file is "Orbit.toml", with case-sensitivity.</p>
<h2 id="working-ip"><a class="header" href="#working-ip">Working ip</a></h2>
<p>Typically, developers work on one project at a given time (while we can work on projects concurrently, we unfortunately are not parallel processors...yet). The <em>working ip</em> is the ip that is currently being developed at a given moment. The working ip is found by Orbit by checking along the working directory and its parent directories. Some Orbit commands only work when they are called within the working ip (<code>orbit lock</code>, <code>orbit build</code>).</p>
<h2 id="types-of-files-inside-an-ip"><a class="header" href="#types-of-files-inside-an-ip">Types of files inside an ip</a></h2>
<p>Since Orbit focuses on digital hardware projects, it automatically detects and manages files that store HDL source code. Files that store HDL source code are called <em>source files</em>. Any other files, such as scripts and test vectors, are considered <em>auxiliary files</em>.</p>
<p>Auxiliary files can be injected into the planning stage by specifying <em>filesets</em> for the given target. A <em>fileset</em> is glob-style pattern that collects matching files under a common name within the working ip. These matched files will appear in the target's generated blueprint file for future execution.</p>
<p>So, what files are inside an ip?</p>
<ul>
<li><em>Source files</em>: Stores HDL source code (VHDL, Verilog)</li>
<li><em>Auxiliary files</em>: Any additional files that do not store source code</li>
<li><em>Manifest file</em> (<code>Orbit.toml</code>): Stores the ip's metadata provided by the user</li>
<li><em>Lock file</em> (<code>Orbit.lock</code>): Saves the ip's world state for reproducibility purposes</li>
</ul>
<p>All files <strong>except the lock file</strong> are expected to be edited by the user. Orbit automatically maintains the lock file to ensure it can reproduce the ip's world state in the future.</p>
<h3 id="reserved-names"><a class="header" href="#reserved-names">Reserved names</a></h3>
<p>File names that begin with ".orbit-" are reserved for internal use and are not allowed at the root directory of an ip. Files that are named with this pattern are used by Orbit in the ip catalog to store additional metadata about the ip.</p>
<h2 id="ip-names"><a class="header" href="#ip-names">Ip names</a></h2>
<p>An ip's name is a human-readable name given to an ip so users can easily recall and locate relevant packages.</p>
<pre><code>gates
</code></pre>
<p>An ip's <em>specification</em>, more commonly called a <em>spec</em>, is the full resolved name of an ip. As of now, the spec involves the ip's name and ip's version separated by a <code>:</code> character.</p>
<pre><code>gates:1.0.0
</code></pre>
<p>When asking Orbit to operate on a particular ip outside of the working ip, Orbit will usually ask you to provide the ip's spec. Orbit uses the spec to lookup the ip in the catalog and then continues operation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="targets"><a class="header" href="#targets">Targets</a></h1>
<p>Orbit operates at the <em>front end</em> of hardware development. At the <em>back end</em> of hardware development is where the true "processing" occurs. A particular "process" that occurs in the back end and produces some result is called a <em>target</em>.</p>
<p>Orbit has no built-in targets. Since hardware development varies widely with the tools available, the environments in which development occurs, and the processes that occur within those environments, Orbit has not built-in targets. This design choice gives users flexibility in configuring the types of workflows that are most important to them.</p>
<p>At the <em>front end</em>, Orbit frequently interacts with the user to handle operations and run processes within their hardware development workflow. The main role of Orbit is to organize, reference, and prepare HDL source code for the <em>back end</em>.</p>
<p>Targets typically take in as input the <em>blueprint</em>, which is the final output file from Orbit that has prepared the list of HDL files for input to the back end.</p>
<h2 id="defining-targets"><a class="header" href="#defining-targets">Defining Targets</a></h2>
<p>Users can setup a target in the configuration file <code>config.toml</code>. For all the available parameters to define a target, see <a href="topic/./../reference/configuration.html#the-target-array">[[target]]</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocols"><a class="header" href="#protocols">Protocols</a></h1>
<p>A <em>protocol</em> is a series of steps requried to get a package from the internet. Protocols exist because there are numerous ways to access data from the internet depending on your development environment. Orbit tries to be as modular and flexible as possible by introducing protocols.</p>
<p>Protocols are required during the download process to acquire a package for potential cache installation.</p>
<h2 id="default-protocol"><a class="header" href="#default-protocol">Default protocol</a></h2>
<p>Orbit has a default protocol that relies on the Rust <a href="https://crates.io/crates/curl"><code>curl</code></a> crate to make HTTP requests. This protocol assumes the provided URLs point to a zip archive containing the targeted package. The protocol will extract the zip file to the <em>queue</em>, which is a special temporary directory handled by Orbit. Orbit generates and manages a different queue directory for each package that must be downloaded.</p>
<h3 id="using-the-default-protocol"><a class="header" href="#using-the-default-protocol">Using the default protocol</a></h3>
<p>To use the default protocol, modify the desired project's manifest to only specify the URL as the source. The default protocol assumes the URL points to a publicly accessible zip archive.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "orbit"
version = "1.0.0"
source = "https://github.com/chaseruskin/orbit/archive/refs/tags/1.0.0.zip"
# ...
</code></pre>
<h2 id="custom-protocols"><a class="header" href="#custom-protocols">Custom protocols</a></h2>
<p>A user can define a custom protocol for accessing packages from the internet by modifying the configuration file.</p>
<p>Orbit sets the current directory for the custom protocol execution to already be the queue directory.
This means when a custom protocol is executed, whatever files it downloads and extracts to the current directory is the directory Orbit expects to find the IP.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>One possible protocol relies on using the <code>git</code> command-line tool.</p>
<p>Filename: config.toml</p>
<pre><code class="language-toml">[[protocol]]
name = "gitit"
summary = "Access packages through git to handle remote repositories"
command = "git"
args = ["clone", "-b", "{{ orbit.ip.version }}", "{{ orbit.ip.source.url }}"]
</code></pre>
<p>This protocol calls <code>git</code> and clones from the IP's URL while checking out the branch/tag that matches the IP's version number. These values are resolved at runtime by Orbit through variable substitution.</p>
<p>More complex protocols may require using a scripting language such as Python to perform the necessary steps.</p>
<h3 id="using-a-custom-protocol"><a class="header" href="#using-a-custom-protocol">Using a custom protocol</a></h3>
<p>To use a custom protocol, modify the desired project's manifest file to specify the URL as well as the defined protocol's name. It is each user of the package's responsibility to ensure the necessary protocol(s) are properly configured in their settings.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
name = "orbit"
version = "1.0.0"
source = { url = "https://github.com/chaseruskin/orbit.git", protocol = "gitit" }
# ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels-1"><a class="header" href="#channels-1">Channels</a></h1>
<p>As your codebase evolves over time, you may have accrued a lot of ips. However, an issue arises regarding <em>discovery</em>- how do others quickly find all ips that have been released?</p>
<p>Orbit solves this problem by using channels. A <em>channel</em> is a lightweight decentralized registry index. In other words, a channel is a directory that contains multiple ip manifests. With this approach, users can simply configure channels to discover the many available released ips.</p>
<p>Channels can be as manual or automated as you prefer. You can configure commands to run for a channel's synchronization hook, pre-publish hook, and post-publish hook. Channels are encouraged to be as automated as possible by defining these fields in the channel's configuration.</p>
<h2 id="adding-a-new-ip-to-a-channel"><a class="header" href="#adding-a-new-ip-to-a-channel">Adding a new ip to a channel</a></h2>
<p>Orbit automates the process of adding an ip to a channel with <code>orbit publish</code>.</p>
<p>The ip's manifest gets placed in the channel by using its generated index path. The index path can be read from the <code>ORBIT_CHAN_INDEX</code> environment variable during a channel's pre-publish or post-publish hook processes.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-toml">[[channel]]
name = "hyperspace-labs"
description = "Available ip from hyperspace labs"
root = "." # Optional, default is "."

# If the channel is stored on the internet, synchronize with its remote location
sync.command = "git"
sync.args = ["pull"]

# Issue this command immediately before adding the ip to the channel
pre.command = "git"
pre.args = ["pull"]

# Issue this command immediately after adding the ip to the channel
post.command = "python"
post.args = ["publish.py"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbitlock"><a class="header" href="#orbitlock">Orbit.lock</a></h1>
<p>The <em>Orbit.lock</em> lock file is a file that captures every dependency required for the current ip. This includes information about exact versions of dependencies and how to get them if any are missing from the cache.</p>
<p>The lock file is managed by Orbit, and formalizes the data the user provided in the <code>Orbit.toml</code> manifest file. The lock file is required for every ip and should not be manually edited.</p>
<p>With a lock file, the current state of the ip can be reproduced at a later time and in any environment. If the current ip uses version control, then it is recommended to track <code>Orbit.lock</code> to ensure reproducibility across environments.</p>
<p>To update the current ip's lock file, use <code>orbit lock</code>. The lock file will also automatically be updated before the build process when using <code>orbit build</code> or <code>orbit test</code>.</p>
<blockquote>
<p><strong>Note:</strong> An ip's lock file contains all the data required by it to reproduce its current state, so it does not require reading the lock files of its dependencies.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-visibility"><a class="header" href="#file-visibility">File Visibility</a></h1>
<p>An ip's manifest allows for users to set an <code>exclude</code> field, which can store a list of user-defined file patterns for Orbit to ignore during file discovery.</p>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>Listing files in the <code>exclude</code> field follow the same syntax as .gitignore files. See the pattern format for more information:</p>
<ul>
<li><a href="https://git-scm.com/docs/gitignore#_pattern_format">.gitignore pattern format</a></li>
</ul>
<h2 id="resolving-errors"><a class="header" href="#resolving-errors">Resolving errors</a></h2>
<p>Orbit prevents duplicate primary design units to be identified within certain situations. For example, duplicate design unit names are not allowed within the same project because Orbit cannot resolve ambiguity in which unit is used where.</p>
<p>An error may look like the following:</p>
<pre><code>error: duplicate primary design units identified as "foo"

location 1: rtl/foo1.vhd:20:1
location 2: rtl/foo2.vhd:1:1

hint: resolve this error by either
    1) renaming one of the units to a unique identifier
    2) adding one of the file paths to the manifest's "ip.exclude" field
</code></pre>
<p>The <code>exclude</code> field can be used in this scenario to tell Orbit to ignore reading a particular file during the HDL source code dependency analysis.</p>
<p>Filename: Orbit.toml</p>
<pre><code class="language-toml">[ip]
# ...
exclude = [
    "rtl/foo2.vhd"
]
</code></pre>
<p>In this example, the value for the above <code>exclude</code> field in the local ip's manifest will resolve the previous error because it prevents Orbit from seeing the file "rtl/foo2.vhd" during any file discovery operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-swapping"><a class="header" href="#string-swapping">String Swapping</a></h1>
<p><em>String swapping</em> is the process of injecting runtime information into specific locations of strings.</p>
<p>This process allows permissible strings to become generic enough to avoid having the user frequently update them with redundant information or accidently recall the incorrect value.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>String swap works with key-value pairs. When Orbit sees the correct syntax indicating a known key, it will replace the key's contents with its value in its location within the string.</p>
<p>To have a key substituted with its value, use double opening curly brackets <code>{{</code> to denote the beginning of a key and double closing curly brackets <code>}}</code> to end the key. Whitespace is ignored around the  key within the curly bracket sequences.</p>
<p>When Orbit gets a permissible string, it will parse the characters to check if a key exists and should be swapped with its value. If it finds a valid known key, then it replaces everything from and within the curly bracket sequences with the variable's value. If it cannot find a valid key that matches the name, it leaves that sequence of the string unmodified.</p>
<h2 id="permissible-strings"><a class="header" href="#permissible-strings">Permissible strings</a></h2>
<p>Not every string is checked for string swapping. Strings that are not allowed to have string swapping ignore any existing keys in the text, leaving the entire string unmodified.</p>
<p>The following lists the instances when a string is permitted to perform string swapping:</p>
<h3 id="manifest-files"><a class="header" href="#manifest-files">Manifest files</a></h3>
<p>The string pattern for an ip's <code>source.url</code> field is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.ip.name</code>: The name of the ip being downloaded.</li>
<li><code>orbit.ip.version</code>: The version of the ip being downloaded.</li>
</ul>
<p>The string pattern for an ip's <code>source.tag</code> field is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.ip.name</code>: The name of the ip being downloaded.</li>
<li><code>orbit.ip.version</code>: The version of the ip being downloaded.</li>
</ul>
<h3 id="fileset-patterns"><a class="header" href="#fileset-patterns">Fileset patterns</a></h3>
<p>The string pattern for a target's fileset configuration is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.top.name</code>: The top-level design unit name.</li>
<li><code>orbit.tb.name</code>: The testbench design unit name.</li>
<li><code>orbit.dut.name</code>: The design-under-test design unit name.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
</ul>
<h3 id="protocol-arguments"><a class="header" href="#protocol-arguments">Protocol arguments</a></h3>
<p>The argument list defined in a protocol's configuration is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.queue</code>: The directory that Orbit expects the ip temporarily placed immediately after download.</li>
<li><code>orbit.ip.name</code>: The name of the ip being downloaded.</li>
<li><code>orbit.ip.version</code>: The version of the ip being downloaded.</li>
<li><code>orbit.ip.source.url</code>: The URL for the ip being downloaded.</li>
<li><code>orbit.ip.source.protocol</code>: The protocol specified by the ip being downloaded</li>
<li><code>orbit.ip.source.tag</code>: The tag (if provided) specified by the ip being downloaded.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
</ul>
<h3 id="target-arguments"><a class="header" href="#target-arguments">Target arguments</a></h3>
<p>The argument list defined in a target's configuration is allowed to contain any of the following keys:</p>
<ul>
<li><code>orbit.ip.name</code>: The name of the local ip.</li>
<li><code>orbit.ip.library</code>: The HDL library of the local ip.</li>
<li><code>orbit.ip.version</code>: The version of the local ip.</li>
<li><code>orbit.ip.checksum</code>: The truncated most recent checksum of the local ip.</li>
<li><code>orbit.env.*</code>: Any environment variables loaded from configuration files.</li>
<li><code>orbit.top.name</code>: The top-level design unit name.</li>
<li><code>orbit.tb.name</code>: The testbench design unit name.</li>
<li><code>orbit.dut.name</code>: The design-under-test design unit name.</li>
</ul>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p>Consider an ip with the following manifest data:</p>
<pre><code class="language-toml">[ip]
name = "foo"
version = "1.2.0"
source = "https://github.com/hyperspace-labs/foo/archive/refs/tags/{{orbit.ip.version}}.zip
</code></pre>
<p>The <code>source</code> field of an ip's manifest is one string that is allowed to string swap. For its string, we specify a key, "orbit.ip.version", by enclosing it in double curly brackets. This tells Orbit that any time it uses this string, it should replace <code>{{orbit.ip.version}}</code> with <code>1.2.0</code>, the value associated with that key.</p>
<p>By using string swapping, we can reduce the amount of times redundant information has to be maintained, or delay providing information when we may not know the value until runtime.</p>
<h2 id="environment-variable-translation-examples"><a class="header" href="#environment-variable-translation-examples">Environment variable translation examples</a></h2>
<p>A key recognized by Orbit during string swapping can be an environment variable key. For an environment variable key to be recognized as a key in the context of string swapping, the environment variable key is converted to lowercase with each "_" character replaced by a "." character.</p>
<p>Consider the environment variables set in an Orbit configuration file:</p>
<pre><code class="language-toml">[env]
foo = "bar"
github-user = "chaseruskin"
Yilinx_Path = "/Users/chase/fpga/bin/yilinx"
</code></pre>
<p>This configuration translates to the following variables:</p>
<div class="table-wrapper"><table><thead><tr><th>TOML <code>[env]</code> entry</th><th>Environment variable</th><th>Substitution variable</th></tr></thead><tbody>
<tr><td><code>foo</code></td><td><code>ORBIT_ENV_FOO</code></td><td><code>orbit.env.foo</code></td></tr>
<tr><td><code>github-user</code></td><td><code>ORBIT_ENV_GITHUB_USER</code></td><td><code>orbit.env.github.user</code></td></tr>
<tr><td><code>Yilinx_Path</code></td><td><code>ORBIT_ENV_YILINX_PATH</code></td><td><code>orbit.env.yilinx.path</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-symbol-transformation"><a class="header" href="#dynamic-symbol-transformation">Dynamic Symbol Transformation</a></h1>
<p>This technique is related to <em>name mangling</em> in programming languages. <em>Name mangling</em> is a technique used to solve problems regarding the need to resolve unique names for programming entities. You can learn more about name mangling <a href="https://en.wikipedia.org/wiki/Name_mangling">here</a>.</p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Before we begin, it is important to understand the problem we are trying to solve. An issue inherent to VHDL, Verilog, SystemVerilog, and many other languages is <em>namespace pollution</em>, which is when a large number of programming language variables/identifiers/units/classes are defined at the global level. To learn more about namespace pollution, <a href="https://stackoverflow.com/questions/8862665/what-does-it-mean-global-namespace-would-be-polluted/13352212">here</a> is a StackOverflow post that explains it in relation to Javascript.</p>
<p>Namespace pollution can lead to <em>namespace clashes</em>. As you define more primary design units at the same scope, you are more likely to have two things that accidently have the same name. This is at the core the problem we are going to solve, because HDL compilers and synthesizers are not built to gracefully handle clashes and will error out when a primary design unit at the same scope has multiple definitions.</p>
<p>In VHDL/Verilog, a common example of a namespace clash is when different files define an entity/module by the same name, which may have different behaviors. Namespace clashes may start to appear when a higher-level ip requires the same entity/module from an ip but as different versions throughout its dependency tree.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>We solve the namespace pollution problem with an algorithm called <em>dynamic symbol transformation</em> (DST). The DST algorithm solves the namespace clashing problem by rewriting conflicts with a new unique identifier without losing information in the original identifier.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>Orbit automatically handles resolving duplicate identifiers for primary design units due to two design contraints. The limitations are:</p>
<ol>
<li>All primary design unit identifiers in the current ip must be unique within the scope of the ip.</li>
<li>All primary design units identifiers in the current ip must be unique within the scope of the ip's direct dependencies. An identifier can be duplicated for primary design units across indirect dependencies.</li>
</ol>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>This section walks through a basic demonstration of the DST algorithm. First, it defines some terminology, and then walks through the algorithm's functionality.</p>
<h3 id="symbols"><a class="header" href="#symbols">Symbols</a></h3>
<p>Within the context of VHDL, let's consider a <em>symbol</em> to be the identifier of a <em>primary design unit</em>. A primary design unit is a VHDL construct that exists at the global namespace. There are four primary design units:</p>
<ul>
<li>entity</li>
<li>package</li>
<li>configuration</li>
<li>context</li>
</ul>
<blockquote>
<p><strong>Note:</strong> VHDL does support the concept of <em>libraries</em>, which can add 1 level of nested scope to a primary design unit, but this implementation only pushes the namespace clashing problem back 1 level.</p>
</blockquote>
<p>Within the context of Verilog/SystemVerilog, let's consider a <em>symbol</em> to be the identifier of a <em>design element</em>. A design element is a Verilog/SystemVerilog construct that exists at the global namespace. For Verilog, there is only two design elements (module and primitive), but for SystemVerilog, there are seven design elements:</p>
<ul>
<li>module</li>
<li>program</li>
<li>interface</li>
<li>checker</li>
<li>package</li>
<li>primitive</li>
<li>configuration</li>
</ul>
<p>In the following code, the symbol <code>nand_g</code> corresponds to a module.</p>
<p>Filename: lab1/nand_g.v</p>
<pre><code class="language-verilog">module nand_g (
  input wire a, 
  input wire b,
  output wire c
);
</code></pre>
<p>Remember that this identifier could appear again at the same namespace level (since its global across all source code files), even if it has a different interface/implementation.</p>
<p>Now imagine you are integrating HDL code from various existing ips. As you instantiate modules within larger modules, you realize there exists another module named <code>nand_g</code> in the hierarchy, but this one has a different behavior and port interface than the previously defined <code>nand_g</code> circuit from the "lab1/" directory.</p>
<p>Filename: lab3/nand_g.v</p>
<pre><code class="language-verilog">module nand_g (
  input wire[3:0] x,
  input wire[3:0] y,
  output wire[3:0] z
);
</code></pre>
<p>Since the current ip requires both code segments, then traditionally your EDA tool would complain to you and be unable to resolve which <code>nand_g</code> to be used where. It then falls on the developer to rename one of the modules where it is defined and everywhere it is referenced, which introduces additional overhead in time and possibilities for errors. This problem is solved with DST.</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>Consider the following project-level ip dependency tree:</p>
<p><img src="topic/./../images/dst-graph1.svg" alt="" /></p>
<p>The gray node (<code>final-project</code>) is the local ip you are currently working within, the green nodes (<code>lab2</code>, <code>lab3</code>) are the direct dependencies to the local ip, and the blue node (<code>lab1</code>) is an indirect dependency to the local ip.</p>
<p>Within each project, there exists one or more HDL source code files describing design units.</p>
<p>Imagine the <code>final-project</code> ip has a module called <code>half_add</code> which is the root of circuit hierarchy. From there, it reuses entities from the other ip.</p>
<p>Consider then HDL-level dependency tree:</p>
<p><img src="topic/./../images/dst-graph2.svg" alt="" /></p>
<p>Notice lab1 and lab3 both have the <code>nand_g</code> module, but their interfaces and functionality are different as previously mentioned. How can we allow both units in the hierarchy while resolving the namespace clash?</p>
<h3 id="transformation"><a class="header" href="#transformation">Transformation</a></h3>
<p>DST identifies namespace clashes within the current dependency graph and automatically resolve the conflicts to produce a clean unambiguous graph.</p>
<p><img src="topic/./../images/dst-graph3.svg" alt="" /></p>
<p>The yellow nodes (<code>lab2</code>, <code>lab1</code>) are the ips that had their source code modified due to DST. Since the modified contents of these ips no longer matches their original contents, the modifications are stored as separate entries in the catalog's cache apart from their original entries.</p>
<p>The red node (<code>nand_g.v</code>) is the HDL design element that must be dynamically renamed due to the namespace clash for <code>nand_g</code>. The identifier <code>nand_g</code> in lab1 was appended with the first 10 digits of the original ip's checksum (<code>fbe4720d0</code>). This transforms lab1's <code>nand_g</code> module into <code>nand_g_fbe4720d0</code>, which is unique and no longer clashes with <code>nand_g</code> in lab3.</p>
<blockquote>
<p><strong>Note:</strong> DST specifically chose to <em>not</em> rename the <code>nand_g</code> from lab3. If had decided to rename the <code>nand_g</code> from lab3, the user would be burdened with tracking and maintaining the new renamed unique identifier in the local ip (final-project). Since DST never renames identifiers in direct dependencies, DST is always abstracted away from the user and has zero overhead. While direct dependencies may be modified due to neigboring an ip that undergoes DST, direct dependencies are never chosen for DST.</p>
</blockquote>
<p>The orange nodes (<code>and_g.v</code>, <code>xor_g.v</code>) are the HDL design elements that reference/instantiate the design element that was marked for symbol transformation. Once the ip targeted for DST (lab1) resolves the namespace clash, we must update the references for this design element in all the upstream neighboring ips (lab2). Since their references are now broken due to <code>nand_g</code> being renamed to <code>nand_g_fbe4720d0</code>, the source code is analyzed and updated to fix the broken references of <code>nand_g</code> to <code>nand_g_fbe4720d0</code>.</p>
<p>The final unambiguous HDL-level dependency graph is the following:</p>
<pre><code>half_add (final-project)
├─ nand_g (lab3)
│  ├─ not_g (lab2)
│  └─ and_g (lab2)*
|     └─ nand_g_fbe4720d0 (lab1)*
└─ xor_g (lab2)*
   └─ nand_g_fbe4720d0 (lab1)*
</code></pre>
<p>The <code>*</code> indicates the modules that had their source code modified to either rename the namespace collision or update its references to the new renamed identifier.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>To recap, DST handled the namespace clash by <em>transforming</em>, or renaming, the module <code>nand_g</code> within lab1. The <code>nand_g</code> identifier was appended with the first 10 digits of the original lab1 ip's checksum (fbe4720d0) to make it <code>nand_g_fbe4720d0</code>. This transformation occurred at that ip's source code level (lab1), and modifications were made to the source code for all dependent neighbors of lab1, which was only lab2 in this example. The source code in lab2 had to be updated to rename the references that were originally <code>nand_g</code> to <code>nand_g_fbe4720d0</code>. Each ip that had source code modifications have their changes saved to their own entries in the catalog's cache, such that the original entries are still intact and available for future use.</p>
<h2 id="emphasis"><a class="header" href="#emphasis">Emphasis</a></h2>
<p>Dynamic symbol transformation lets Orbit avoid the major issues and frustrations of package management that stem from dependency incompatibility. As projects grow in complexity and the number of dependencies increases, Orbit can continue to allow users to integrate different verisons of the same package throughout the overall design while retaining dependency compatibility. Conflicts in incompatible versions are avoided within the dependency graph through DST. You can learn more about dependency incompatibility <a href="https://en.wikipedia.org/wiki/Dependency_hell">here</a>.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li>https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section provides technical information for the various components used throughout <code>orbit</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manifest"><a class="header" href="#manifest">Manifest</a></h1>
<p>The <code>Orbit.toml</code> file for each ip is called its manifest. It is written in the <a href="https://toml.io/en/">TOML</a> format. It is maintained by the user and contains metadata that is needed to build the ip. The manifest is read by Orbit to help automatically generate the ip's lock file, <code>Orbit.lock</code>.</p>
<blockquote>
<p><strong>Note:</strong> The manifest's file name is "Orbit.toml", with respect to case-sensitivity.</p>
</blockquote>
<p>Every manifest file consists of the following sections:</p>
<ul>
<li><a href="reference/manifest.html#the-ip-section">[ip]</a> - Defines an ip.
<ul>
<li><a href="reference/manifest.html#the-name-field">name</a> - The name of the ip.</li>
<li><a href="reference/manifest.html#the-uuid-field">uuid</a> - The universally unique identifier of the ip.</li>
<li><a href="reference/manifest.html#the-description-field">description</a> - A short description of the ip.</li>
<li><a href="reference/manifest.html#the-version-field">version</a> - The version of the ip.</li>
<li><a href="reference/manifest.html#the-authors-field">authors</a> - The authors of the ip.</li>
<li><a href="reference/manifest.html#the-library-field">library</a> - The HDL library for the design units within the ip.</li>
<li><a href="reference/manifest.html#the-keywords-field">keywords</a> - A list of simple words categorizing the ip.</li>
<li><a href="reference/manifest.html#the-source-field">source</a> - The URL for remotely retrieving the ip.</li>
<li><a href="reference/manifest.html#the-channels-field">channels</a> - The channels to update when publishing the ip.</li>
<li><a href="reference/manifest.html#the-public-field">public</a> - Files to be visible to other ip.</li>
<li><a href="reference/manifest.html#the-include-field">include</a> - Files to include during file discovery.</li>
<li><a href="reference/manifest.html#the-exclude-field">exclude</a> - Files to exclude during file discovery.</li>
<li><a href="reference/manifest.html#the-readme-field">readme</a> - The path to the README file.</li>
<li><a href="reference/manifest.html#the-metadata-section">[metadata]</a> - An unchecked section for custom fields.</li>
</ul>
</li>
<li><a href="reference/manifest.html#the-dependencies-section">[dependencies]</a> - Ip dependencies.</li>
<li><a href="reference/manifest.html#the-dev-dependencies-section">[dev-dependencies]</a> - Ip dependencies only used for ongoing development.</li>
</ul>
<h3 id="the-ip-section"><a class="header" href="#the-ip-section">The <code>[ip]</code> section</a></h3>
<p>The first section in a <code>Orbit.toml</code> file is <code>[ip]</code>.</p>
<pre><code class="language-toml">[ip]
name = "my-ip" # the name of the package
uuid = "ecj831jmc018hhhgl1d4rzgw8" # the universally unique identifier
version = "0.1.0" # the current version
</code></pre>
<p>The only fields required by Orbit are name, uuid, and version.</p>
<h3 id="the-name-field"><a class="header" href="#the-name-field">The <code>name</code> field</a></h3>
<pre><code class="language-toml">[ip]
name = "my-ip"
# ...
</code></pre>
<h3 id="the-uuid-field"><a class="header" href="#the-uuid-field">The <code>uuid</code> field</a></h3>
<p>A random string consisting of 25 characters in base36 encoding (a-z0-9).</p>
<pre><code class="language-toml">[ip]
# ...
uuid = "ecj831jmc018hhhgl1d4rzgw8"
</code></pre>
<h3 id="the-version-field"><a class="header" href="#the-version-field">The <code>version</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
version = "0.1.0"
</code></pre>
<h3 id="the-authors-field"><a class="header" href="#the-authors-field">The <code>authors</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
authors = ["Duncan Idaho", "Gurney Halleck"]

</code></pre>
<h3 id="the-library-field"><a class="header" href="#the-library-field">The <code>library</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
library = "work"
</code></pre>
<h3 id="the-description-field"><a class="header" href="#the-description-field">The <code>description</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
description = "A short description of the ip"
</code></pre>
<h3 id="the-keywords-field"><a class="header" href="#the-keywords-field">The <code>keywords</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
keywords = ["cpu", "risc"]
</code></pre>
<h3 id="the-source-field"><a class="header" href="#the-source-field">The <code>source</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
source = "https://github.com/chaseruskin/orbit/archive/refs/tags/1.0.0.zip"
</code></pre>
<pre><code class="language-toml">[ip]
# ...
source = { url = "https://github.com/chaseruskin/orbit.git", protocol = "git", tag = "1.0.0" }
</code></pre>
<p>The source field's "url" and "tag" support <a href="reference/./../topic/swapping.html"><em>string swapping</em></a>.</p>
<h3 id="the-channels-field"><a class="header" href="#the-channels-field">The <code>channels</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
channels = ["hyperspace-labs"]
</code></pre>
<h3 id="the-public-field"><a class="header" href="#the-public-field">The <code>public</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
public = ["/rtl"]
</code></pre>
<p>The <code>public</code> field can be used to explicitly specify which files are visible to other ip when being when being referenced as a dependency. The list contains glob-style patterns that conform to .gitignore file semantics, and are always compared relative that ip's root directory.</p>
<p>If no <code>public</code> field is present, then all files are implicitly specified as visible (public) to other ip when being referenced as a dependency.</p>
<h3 id="the-include-field"><a class="header" href="#the-include-field">The <code>include</code> field</a></h3>
<p>The <code>include</code> field can be used to explicitly specify which files to include during source code analysis.</p>
<pre><code class="language-toml">[ip]
# ...
include = ["/rtl"]
</code></pre>
<p>Using <code>include</code> and <code>exclude</code> is mutually exclusive; setting <code>include</code> will override any value of <code>exclude</code>. If <code>include</code> and <code>exclude</code> are omitted, then all files from the root of the ip will be included.</p>
<h3 id="the-exclude-field"><a class="header" href="#the-exclude-field">The <code>exclude</code> field</a></h3>
<p>The <code>exclude</code> field can be used to explicitly specify which files to exclude during source code analysis.</p>
<pre><code class="language-toml">[ip]
# ...
exclude = ["/deprec"]
</code></pre>
<p>Using <code>include</code> and <code>exclude</code> is mutually exclusive; setting <code>include</code> will override any value of <code>exclude</code>. If <code>include</code> and <code>exclude</code> are omitted, then all files from the root of the ip will be included.</p>
<p>Files that are always excluded are those found in directories that contain a "CACHEDIR.TAG" file. For example, every target output directory Orbit creates is excluded because they contain this file.</p>
<h3 id="the-readme-field"><a class="header" href="#the-readme-field">The <code>readme</code> field</a></h3>
<pre><code class="language-toml">[ip]
# ...
readme = "README.md"
</code></pre>
<h3 id="the-metadata-section"><a class="header" href="#the-metadata-section">The <code>[metadata]</code> section</a></h3>
<p>Any type of TOML entry is allowed in this section, as Orbit ignores this section.</p>
<pre><code class="language-toml">[ip.metadata]
custom-field-1 = true
custom-field-2 = "hello world"
# ...
</code></pre>
<h3 id="the-dependencies-section"><a class="header" href="#the-dependencies-section">The <code>[dependencies]</code> section</a></h3>
<p>The <code>[dependencies]</code> section is a table of direct dependencies required for the current ip.</p>
<pre><code class="language-toml">[dependencies]
gates = "1.0.0"
uart = "2.3.1"
</code></pre>
<p>If the ip has no dependencies, the section can be omitted from the manifest. The ips listed in this section will always be included in the build graph.</p>
<h3 id="the-dev-dependencies-section"><a class="header" href="#the-dev-dependencies-section">The <code>[dev-dependencies]</code> section</a></h3>
<p>The <code>[dev-dependencies]</code> section is a table of direct dependencies required for the current ip.</p>
<pre><code class="language-toml">[dev-dependencies]
testkit = "1.3.7"
logic-analyzer = "4.8.0"
</code></pre>
<p>If the ip has no development dependencies, the section can be omitted from the manifest. The ips listed in this section will not be included in the build graph for when this ip is used as a dependency itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="names"><a class="header" href="#names">Names</a></h1>
<p>In order to identify an ip among others, Orbit requires users to assign a human-readable <em>name</em> to each created ip. In addition to the human-readable name, Orbit assigns a <em>universally unique identifier</em> (UUID) to each ip. UUIDs are required in order to avoid namespace collisions at the ip level in Orbit's decentralized system.</p>
<h2 id="name"><a class="header" href="#name">Name</a></h2>
<p>The ip <em>name</em> is a unique string of characters that abides by a certain set of rules. It is a single name and is defined under the "name" field in an ip's manifest. Every ip is required to have a name. The name should not change over the course of an ip's lifetime.</p>
<pre><code class="language-toml">[ip]
name = "cpu"
# ...
</code></pre>
<h3 id="rules"><a class="header" href="#rules">Rules</a></h3>
<p>The following rules currently apply to a name values:</p>
<ul>
<li>begins with an ASCII letter (<code>a-z</code>, <code>A-Z</code>)</li>
<li>contains only ASCII letters (<code>a-z</code>, <code>A-Z</code>), ASCII digits (<code>0-9</code>), dashes <code>-</code>, and underscores <code>_</code></li>
<li>cannot end with a dash <code>-</code> or underscore <code>_</code></li>
</ul>
<h2 id="uuid"><a class="header" href="#uuid">UUID</a></h2>
<p>The ip <em>uuid</em> is a unique string of characters encoded in base36 (a-z0-9). An encoded UUID is 25 characters long and is generated using Version 4 UUID. It is defined under the "uuid" field in an ip's manifest. Every ip is required to have a uuid. The uuid should not change over the course of an ip's lifetime.</p>
<pre><code class="language-toml">[ip]
# ...
uuid = "71vs0nyo7lqjji6p6uzfviaoi"
</code></pre>
<h3 id="rules-1"><a class="header" href="#rules-1">Rules</a></h3>
<p>The following rules currently apply to uuid values:</p>
<ul>
<li>contains only ASCII lowercase letters (<code>a-z</code>) and ASCII digits (<code>0-9</code>)</li>
<li>is 25 characters long</li>
</ul>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>The ip <em>version</em> is a series of 3 numbers separated by decimal characters (<code>.</code>) with an optional label suffix attached with a dash character (<code>-</code>). The version should be updated over the course of an ip's lifetime when significant enough changes to the project require a new version value.</p>
<pre><code class="language-toml">[ip]
# ...
version = "1.0.0"
</code></pre>
<h3 id="rules-2"><a class="header" href="#rules-2">Rules</a></h3>
<p>The following rules currently apply to version values:</p>
<ul>
<li>contains only ASCII digits (<code>0-9</code>) for each of the 3 version fields</li>
<li>each version field is separated by a decimal character (<code>.</code>)</li>
<li>a label can be attached to the end by using a dash character (<code>-</code>)</li>
<li>labels can only contain ASCII letters (<code>a-z</code>, <code>A-Z</code>), ASCII digits (<code>0-9</code>), and decimal characters (<code>.</code>)</li>
</ul>
<h2 id="ip-specification"><a class="header" href="#ip-specification">Ip specification</a></h2>
<p>An ip specification, commonly abbreviated to <em>spec</em>, is the total unambiguous reference to a specific ip at a particular version.</p>
<pre><code>spec ::= &lt;name&gt;[+uuid][:version]
</code></pre>
<h3 id="example-specifications"><a class="header" href="#example-specifications">Example specifications</a></h3>
<p>The following provides various valid inputs when defining an ip's spec and how it decomposes into its parts.</p>
<div class="table-wrapper"><table><thead><tr><th>Spec</th><th>Name</th><th>UUID</th><th>Version</th></tr></thead><tbody>
<tr><td><code>gates:1.0.0</code></td><td><code>gates</code></td><td>Automatically resolved if only 1 ip exists with the name <code>gates</code></td><td><code>1.0.0</code></td></tr>
<tr><td><code>ram</code></td><td><code>ram</code></td><td>Automatically resolved if only 1 ip exists with the name <code>ram</code></td><td><code>latest</code></td></tr>
<tr><td><code>fifo:2.3</code></td><td><code>fifo</code></td><td>Automatically resolved if only 1 ip exists with the name <code>fifo</code></td><td><code>2.3.*</code></td></tr>
<tr><td><code>cpu+71vs0nyo7lqjji6p6uzfviaoi:1.0.0</code></td><td><code>cpu</code></td><td><code>71vs0nyo7lqjji6p6uzfviaoi</code></td><td><code>1.0.0</code></td></tr>
</tbody></table>
</div>
<h3 id="namespace-collisions"><a class="header" href="#namespace-collisions">Namespace Collisions</a></h3>
<p>Two different ip's may share a common name within the catalog even though their contents are different. Two names are considered equal if their lowercase mapping is identical, where dashes (<code>-</code>) also map to underscores (<code>_</code>).</p>
<div class="table-wrapper"><table><thead><tr><th>Spec 1</th><th>Spec 2</th><th>Collision</th></tr></thead><tbody>
<tr><td><code>gates</code></td><td><code>GATES</code></td><td>true</td></tr>
<tr><td><code>ram</code></td><td><code>rom</code></td><td>false</td></tr>
<tr><td><code>fifo_cdc</code></td><td><code>Fifo-CDC</code></td><td>true</td></tr>
</tbody></table>
</div>
<p>To resolve namespace collisions at the ip level, Orbit uses UUIDs. When there are multiple ips in the catalog that share the same name, a user must then explicitly include the UUID of the requested ip to disambiguate between ips under the same name.</p>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<p>An ip can optionally belong to a library. An ip's <em>library</em> is a higher-level scope that loosely groups together multiple ips. This library identification is used for grouping the HDL source code itself into their language-defined libraries as well.</p>
<p>A library can be defined through the "library" field in the ip's manifest file. Its format follows the same rules as the ip's name. If no library is defined in the ip's manifest, then the default library is the ip's name.</p>
<p>An ip is <em>not</em> allowed to have "work" explicitly set as its library in the ip's manifest. The "work" library is a reserved library within the context of VHDL used to reference other primary design units within that of the current library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versions"><a class="header" href="#versions">Versions</a></h1>
<p>Code evolves over time, and versions provide a method for capturing a project's state at a given time stamp.</p>
<p>Orbit uses the <em>semantic versioning</em> scheme for capturing project's state at given time periods. Semantic versioning uses 3 numeric values to signify different levels of change.</p>
<pre><code>version ::= major "." minor "." micro [ "-" label ]
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Explanation</th></tr></thead><tbody>
<tr><td>Major</td><td>Incompatible API changes</td></tr>
<tr><td>Minor</td><td>Adding functionality in backward-compatible way</td></tr>
<tr><td>Micro</td><td>Fixing bugs in backward-compatible way</td></tr>
<tr><td>Label</td><td>Descriptive modifier to show status of upcoming version</td></tr>
</tbody></table>
</div>
<p>To learn more about semantic versioning, visit the official <a href="https://semver.org">website</a>.</p>
<p>Determining the next version number based on a project's recent code changes can be an opinionated process, so it's recommended to also keep a changelog highlighting the differences among versions.</p>
<blockquote>
<p><strong>Note:</strong> An alternative to <em>semantic versioning</em> is <em>calender versioning</em>, which
also operates on the basis of using 3 digits. To learn more about <em>calender versioning</em> visit the official <a href="https://calver.org">website</a>.</p>
</blockquote>
<h2 id="rules-3"><a class="header" href="#rules-3">Rules</a></h2>
<ul>
<li>Each level may only contain ASCII digits (<code>0-9</code>).</li>
<li>A label must follow a dash character (<code>-</code>) and cannot be empty.</li>
<li>Labels can consist of ASCII letters (<code>a-z</code>, <code>A-Z</code>), ASCII digits (<code>0-9</code>), and/or decimal characters (<code>.</code>)</li>
</ul>
<p>All 3 levels must be given a numeric value consisting of only digits separated by a dot (<code>.</code>) character. This is considered a <em>fully qualified</em> version.</p>
<pre><code>1.0.0
</code></pre>
<p>In some scenarios a <em>partially qualified</em> version can be accepted. This means one or more of the version's levels are omitted. A label is not required for a version to be considered fully qualified.</p>
<pre><code>1
1.0
</code></pre>
<p>When given a partially qualified version, Orbit references the maximum version available that satifies the partially qualified version. If no version is specified, it assumes the request is for the latest known version. The latest known version can also be explicitly requested by inputting <code>latest</code> as the version. Assume the known released versions for a given IP are as listed:</p>
<div class="table-wrapper"><table><thead><tr><th>Versions</th></tr></thead><tbody>
<tr><td><code>2.1.0</code></td></tr>
<tr><td><code>1.5.0</code></td></tr>
<tr><td><code>1.2.1</code></td></tr>
<tr><td><code>1.2.0</code></td></tr>
<tr><td><code>1.0.0</code></td></tr>
</tbody></table>
</div>
<p>The following illustrates the mapping from the partially specified requested version to its fully specified known version that would be returned:</p>
<div class="table-wrapper"><table><thead><tr><th>Requested</th><th>Returned</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>1.5.0</code></td></tr>
<tr><td><code>1.1</code></td><td><code>NOT FOUND</code></td></tr>
<tr><td><code>1.2</code></td><td><code>1.2.1</code></td></tr>
<tr><td><code>2</code></td><td><code>2.1.0</code></td></tr>
<tr><td><code>1.2.0</code></td><td><code>1.2.0</code></td></tr>
<tr><td><code>latest</code></td><td><code>2.1.0</code></td></tr>
<tr><td><code>(omitted)</code></td><td><code>2.1.0</code></td></tr>
</tbody></table>
</div>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>A fully qualified version must be written in every project's manifest file.</p>
<pre><code class="language-toml">[ip]
# ...
version = "1.5.4"
# ...
</code></pre>
<p>A specific (or partially speific) version can be requested for an IP on the command-line by placing a colon <code>:</code> character between the package's name and the requested version.</p>
<pre><code>$ orbit install gates:1.5.4
$ orbit get nor_gate --ip gates:1.5
</code></pre>
<h2 id="comparing-versions"><a class="header" href="#comparing-versions">Comparing versions</a></h2>
<p>The following pseudocode provides additional help in learning about how versions are compared (selecting a "higher" version).</p>
<pre><code>IF major levels are not equal:
    RETURN version with larger major level value.
ELSE IF minor levels are not equal:
    RETURN version with larger minor level value.
ELSE:
    RETURN version with larger patch level value. 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesets"><a class="header" href="#filesets">Filesets</a></h1>
<p>A <em>fileset</em> is group of files identified by a common file pattern. Typically they are denoted by a common file extension, such as <code>.txt</code>, but a fileset can more broadly be grouped under any glob-style pattern.</p>
<p>A fileset itself consists of a name and a pattern.</p>
<ul>
<li>The name is a string that is normalized to ALL-UPPERCASE-WITH-HYPENS. It is used to identify which fileset a file belongs to.</li>
<li>The pattern is a glob-style pattern. It is used to perform glob-style matching when searching the file system for files to add to a fileset.</li>
</ul>
<h2 id="built-in-filesets"><a class="header" href="#built-in-filesets">Built-in filesets</a></h2>
<p>There are built-in filesets that Orbit uses that have special rules and work across all ip, including dependencies. The following filesets are currently built-in with Orbit:</p>
<ul>
<li><code>VHDL</code>: VHDL files (.vhd, .vhdl)</li>
<li><code>VLOG</code>: Verilog files (.v, .vl, .verilog, .vlg, .vh)</li>
<li><code>SYSV</code>: SystemVerilog files (.sv, .svh)</li>
</ul>
<h2 id="custom-filesets"><a class="header" href="#custom-filesets">Custom filesets</a></h2>
<p>Custom filesets are filesets that are be defined by the user for a specific target. These filesets are only searched for in the local ip and do not extend any of the ip's dependencies.</p>
<p>If the pattern does not start with an explicit relative path symbol (<code>.</code>), then Orbit assumes to look for the fileset across every possible path in the local ip by implicitly prepending the pattern with <code>**/</code>.</p>
<h2 id="name-normalization-examples"><a class="header" href="#name-normalization-examples">Name normalization examples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User-defined Fileset</th><th>Normalized Fileset</th></tr></thead><tbody>
<tr><td>GOOD-SET</td><td>GOOD-SET</td></tr>
<tr><td>Set-1</td><td>SET-1</td></tr>
<tr><td>set_2</td><td>SET-2</td></tr>
<tr><td>set_three</td><td>SET-THREE</td></tr>
</tbody></table>
</div>
<p>The normalized fileset name is the name that will be written to the blueprint file when collecting filesets. This design choice is for consistency across targets when reading and parsing the blueprint.</p>
<h2 id="custom-pattern-assumption-examples"><a class="header" href="#custom-pattern-assumption-examples">Custom pattern assumption examples</a></h2>
<div class="table-wrapper"><table><thead><tr><th>User-defined pattern</th><th>Interpreted pattern</th></tr></thead><tbody>
<tr><td><code>*.txt</code></td><td><code>**/*.txt</code></td></tr>
<tr><td><code>Boards/*.toml</code></td><td><code>**/Boards/*.toml</code></td></tr>
<tr><td><code>./specific/path.log</code></td><td><code>./specific/path.log</code></td></tr>
</tbody></table>
</div>
<p>The custom patterns begin their search for files at the local ip's root directory. The interpreted pattern is the actual glob-style pattern used when collecting files for custom filesets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint"><a class="header" href="#blueprint">Blueprint</a></h1>
<p>The <em>blueprint</em> is a file containing a list of files required for a particular back end. This single file is the main method Orbit uses to communicate information to a target's process.</p>
<p>When the blueprint is created, it is saved to the local ip's target output directory.</p>
<h2 id="formats"><a class="header" href="#formats">Formats</a></h2>
<p>The currently supported formats are:</p>
<ul>
<li><a href="reference/blueprint.html#tab-separated-values">Tab-separated values</a>: <code>blueprint.tsv</code></li>
</ul>
<h2 id="specifications"><a class="header" href="#specifications">Specifications</a></h2>
<p>Each blueprint format may contain different information and store it in a different way. Refer to each specification to see exactly how the data is communicated through their blueprint.</p>
<p>Attributes that are consistent across all formats are the fileset, library, and filepath.</p>
<p>The <em>fileset</em> is the group name for the file pattern that matched the given rule's file.</p>
<p>The <em>library</em> is the hdl defined library for the ip which the given file at this particular step was found.</p>
<p>The <em>filepath</em> is the absolute file system path to the given rule's file.</p>
<h3 id="built-in-filesets-1"><a class="header" href="#built-in-filesets-1">Built-in Filesets</a></h3>
<p>The following filesets are already recognized by Orbit and are used for identifying hdl source code:</p>
<div class="table-wrapper"><table><thead><tr><th>Fileset</th><th>Supported file extensions</th></tr></thead><tbody>
<tr><td><code>VHDL</code></td><td>.vhd, .vhdl</td></tr>
<tr><td><code>VLOG</code></td><td>.v, .vl, .verilog, .vlg, .vh</td></tr>
<tr><td><code>SYSV</code></td><td>.sv, .svh</td></tr>
</tbody></table>
</div>
<h2 id="tab-separated-values"><a class="header" href="#tab-separated-values">Tab-separated values</a></h2>
<ul>
<li>Advantages
<ul>
<li>Simple and easy to parse for back ends</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Limited information is sent</li>
</ul>
</li>
</ul>
<p>The file is divided into a series of <em>steps</em>, each separated by a newline character (<code>\n</code>).</p>
<pre><code>STEP
STEP
...
</code></pre>
<p>A step contains information about a particular file. Every step always has 3 components: a fileset, a library, and a filepath. Each component in a step is separated by a tab character (<code>\t</code>).</p>
<pre><code>FILESET	LIBRARY	FILEPATH
</code></pre>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<pre><code class="language-text">PYMDL	lc3b	/Users/chase/projects/lc3b/sim/models/alu_tb.py
VHDL	lc3b	/Users/chase/projects/lc3b/rtl/const_pkg.vhd
VHDL	base2	/Users/chase/.orbit/cache/base2-1.0.0-aac9159285/pkg/base2.vhd
VHDL	lc3b	/Users/chase/projects/lc3b/rtl/alu.vhd
VHDL	lc3b	/Users/chase/projects/lc3b/sim/alu_tb.vhd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>Orbit's configuration can be customized with the setting of specific environment variables. These variables can be accessed anytime Orbit is executed.</p>
<ul>
<li>
<p><code>ORBIT_HOME</code> - Location where Orbit stores its data. By default Orbit reads and writes to "$HOME/.orbit" on Unix systems and "%USERPROFILE%/.orbit" on Windows systems.</p>
</li>
<li>
<p><code>NO_COLOR</code> - If set, do not print colorized output to the terminal.</p>
</li>
<li>
<p><code>ORBIT_WIN_LITERAL_CMD</code> - If set, disables the default behavior of checking for programs ending with ".exe" then ".bat" when a program name without extension is not found on Windows systems.</p>
</li>
</ul>
<h2 id="runtime-environment-variables"><a class="header" href="#runtime-environment-variables">Runtime environment variables</a></h2>
<p>Orbit also sets environment variables during runtime such that any subprocesses within Orbit, such as targets, can access necessary information.</p>
<ul>
<li>
<p><code>ORBIT_MANIFEST_DIR</code> - The full path for the directory that contains the current ip's manifest.</p>
</li>
<li>
<p><code>ORBIT_IP_NAME</code> - The name of the current ip.</p>
</li>
<li>
<p><code>ORBIT_IP_UUID</code> - The uuid of the current ip.</p>
</li>
<li>
<p><code>ORBIT_IP_LIBRARY</code> - The interpretated HDL library of the current ip.</p>
</li>
<li>
<p><code>ORBIT_IP_VERSION</code> - The version of the current ip.</p>
</li>
<li>
<p><code>ORBIT_IP_CHECKSUM</code> - The first 10 characters from the latest checksum of the current ip.</p>
</li>
<li>
<p><code>ORBIT_TARGET</code> - The name of the target selected for the latest build process.</p>
</li>
<li>
<p><code>ORBIT_TOP_NAME</code> - The top level design's identifier for the latest build process, only if the build process was a build.</p>
</li>
<li>
<p><code>ORBIT_TOP_FILE</code> - The file system path that contains the top level design for the latest build process, only if the build process was a build.</p>
</li>
<li>
<p><code>ORBIT_TOP_JSON</code> - The serialized json data for the top level design unit for the latest build process, only if the build process was a build (see <a href="reference/json.html">JSON Output</a>).</p>
</li>
<li>
<p><code>ORBIT_TB_NAME</code> - The testbench's identifier for the latest build process, only if the build process was a test.</p>
</li>
<li>
<p><code>ORBIT_TB_FILE</code> - The file system path that contains the testbench for the latest build process, only if the build process was a test.</p>
</li>
<li>
<p><code>ORBIT_TB_JSON</code> - The serialized json data for the testbench for the latest build process, only if the build process was a test (see <a href="reference/json.html">JSON Output</a>).</p>
</li>
<li>
<p><code>ORBIT_DUT_NAME</code> - The design under test's identifier for the latest build process, only if the build process was a test.</p>
</li>
<li>
<p><code>ORBIT_DUT_FILE</code> - The file system path that contains the design under test for the latest build process, only if the build process was a test.</p>
</li>
<li>
<p><code>ORBIT_DUT_JSON</code> - The serialized json data for the design under test for the latest build process, only if the build process was a test (see <a href="reference/json.html">JSON Output</a>).</p>
</li>
<li>
<p><code>ORBIT_BLUEPRINT</code> - The file name for the blueprint created from the planning stage of the latest build process. The file name includes the file's extension.</p>
</li>
<li>
<p><code>ORBIT_TARGET_DIR</code> - Directory where all generated artifacts from any targets will be stored, relative to the current ip's directory. Default is "target".</p>
</li>
<li>
<p><code>ORBIT_OUT_DIR</code> - The folder where all generated artifacts for the current target will be stored. This folder is inside the target directory for the current ip, and is unique for each selected target. Default is the target's name.</p>
</li>
<li>
<p><code>ORBIT_CHAN_INDEX</code> - The full path for the directory where the current ip's manifest will be placed for the current channel in the publishing process.</p>
</li>
</ul>
<h2 id="checking-the-environment"><a class="header" href="#checking-the-environment">Checking the environment</a></h2>
<p>See <a href="reference/./../commands/env.html"><code>orbit env</code></a> for checking environment variables on the command-line. Not all environment variables, especially runtime environment variables, may be available.</p>
<!--
Note about environment variables vs. settings file vs. arguments

precedence:
1. config file
2. env vars
3. command-line
--><div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>The <code>config.toml</code> file stores settings and extends Orbit's functionality. It is written in the <a href="https://toml.io/en/">TOML</a> format. It is maintained by the developer and can be shared across teams for consistent development environments.</p>
<blockquote>
<p><strong>Note:</strong> The configuration's file name is "config.toml", with respect to case-sensitivity.</p>
</blockquote>
<h2 id="paths"><a class="header" href="#paths">Paths</a></h2>
<p>When a field is expected to be a file system path, Orbit has the ability to resolve relative paths. The path is determined in relation to the currently processed <code>config.toml</code>'s parent directory. This design choice was implemented in order to allow for path definitions to be valid across developer machines when sharing configurations. It is recommended to use relative paths when setting a path to a field in a <code>config.toml</code>.</p>
<h2 id="precedence"><a class="header" href="#precedence">Precedence</a></h2>
<p>Orbit supports multiple levels of configuration. Each level has its own order of precedence. The order of precedence is the following:</p>
<ol>
<li>
<p>Local configuration file (current ip's <code>.orbit/conifg.toml</code>)</p>
</li>
<li>
<p>Regional configuration files (parent directories of the current working directory)</p>
</li>
<li>
<p>Global configuration file (Orbit's <code>$ORBIT_HOME/config.toml</code>)</p>
</li>
<li>
<p>Included configuration files (order-preserving list found for the global configuration's <a href="reference/configuration.html#the-include-field"><code>include</code></a> field)</p>
</li>
</ol>
<p>The configuration files are processed in the order defined above. When a configuration file defines a field, no other configuration files later in the process will be able to override its value. If a field is never provided an explicit value, the Orbit's default will be used.</p>
<blockquote>
<p><strong>Tip:</strong> You can modify some values in the configuration file through the command-line by using the <code>orbit config</code> command.</p>
</blockquote>
<p>Every configuration file consists of the following sections:</p>
<ul>
<li><a href="reference/configuration.html#the-include-field">include</a> - Lists other <code>config.toml</code> files to process. This field is only allowed for the global configuration file.</li>
<li><a href="reference/configuration.html#the-general-section">[general]</a> - The general settings.
<ul>
<li><a href="reference/configuration.html#the-target-dir-field">target-dir</a> - Default target directory.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-test-section">[test]</a> - The test settings.
<ul>
<li><a href="reference/configuration.html#the-default-target-field">default-target</a> - Set the default target for tests.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-build-section">[build]</a> - The build settings.
<ul>
<li><a href="reference/configuration.html#the-default-target-field">default-target</a> - Set the default target for builds.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-vhdl-format-section">[vhdl-format]</a> - VHDL code formatting.</li>
<li><a href="reference/configuration.html#the-verilog-format-section">[verilog-format]</a> - SystemVerilog/Verilog code formatting.</li>
<li><a href="reference/configuration.html#the-env-section">[env]</a> - The runtime environment variables.</li>
<li><a href="reference/configuration.html#the-target-array">[[target]]</a> - Define a target.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the target.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the target.</li>
<li><a href="reference/configuration.html#the-command-field">command</a> - The command to execute the target.</li>
<li><a href="reference/configuration.html#the-args-field">args</a> - Arguments to pass to the command.</li>
<li><a href="reference/configuration.html#the-plans-field">plans</a> - The list of supported blueprint file formats.</li>
<li><a href="reference/configuration.html#the-fileset-section">[fileset]</a> - Filesets to collect for the target.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-protocol-array">[[protocol]]</a> - Define a protocol.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the protocol.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the protocol.</li>
<li><a href="reference/configuration.html#the-command-field">command</a> - The command to execute the protocol.</li>
<li><a href="reference/configuration.html#the-args-field">args</a> - Arguments to pass to the command.</li>
</ul>
</li>
<li><a href="reference/configuration.html#the-channel-array">[[channel]]</a> - Define a channel.
<ul>
<li><a href="reference/configuration.html#the-name-field">name</a> - The name of the channel.</li>
<li><a href="reference/configuration.html#the-description-field">description</a> - A short description of the channel.</li>
<li><a href="reference/configuration.html#the-root-field">root</a> - The directory where the channel exists.</li>
<li><a href="reference/configuration.html#the-command-field">sync.command</a> - The command to execute when synchronizing the channel.</li>
<li><a href="reference/configuration.html#the-args-field">sync.args</a> - Arguments to pass to the command during synchronization.</li>
<li><a href="reference/configuration.html#the-command-field">pre.command</a> - The command to execute immediately before launch.</li>
<li><a href="reference/configuration.html#the-command-field">pre.args</a> - Arguments to pass to the command immediately before launch.</li>
<li><a href="reference/configuration.html#the-command-field">post.command</a> - The command to execute immediately after launch.</li>
<li><a href="reference/configuration.html#the-args-field">post.args</a> - Arguments to pass to the command immediately after launch.</li>
</ul>
</li>
</ul>
<h3 id="the-include-field-1"><a class="header" href="#the-include-field-1">The <code>include</code> field</a></h3>
<pre><code class="language-toml">include = [
    "profiles/p1/config.toml",
    "profiles/p2/config.toml",
    "channels/c1/config.toml"
]
</code></pre>
<h3 id="the-general-section"><a class="header" href="#the-general-section">The <code>[general]</code> section</a></h3>
<h3 id="the-target-dir-field"><a class="header" href="#the-target-dir-field">The <code>target-dir</code> field</a></h3>
<p>Define the default output directory to create for the planning and building phases. This value can be overridden on the command-line when the <code>--target-dir</code> option is available. When this field is not defined, the default value for the build directory is "target".</p>
<pre><code class="language-toml">[general]
target-dir = "target"
# ...
</code></pre>
<h3 id="the-test-section"><a class="header" href="#the-test-section">The <code>[test]</code> section</a></h3>
<h3 id="the-default-target-field"><a class="header" href="#the-default-target-field">The <code>default-target</code> field</a></h3>
<p>Sets the default target when calling <code>orbit test</code>. If the default target is set to be used and it cannot be found among the known targets, it will error.</p>
<pre><code class="language-toml">[test]
default-target = "foo"
</code></pre>
<h3 id="the-build-section"><a class="header" href="#the-build-section">The <code>[build]</code> section</a></h3>
<h3 id="the-default-target-field-1"><a class="header" href="#the-default-target-field-1">The <code>default-target</code> field</a></h3>
<p>Sets the default target when calling <code>orbit build</code>. If the default target is set to be used and it cannot be found among the known targets, it will error.</p>
<pre><code class="language-toml">[build]
default-target = "bar"
</code></pre>
<h3 id="the-vhdl-format-section"><a class="header" href="#the-vhdl-format-section">The <code>[vhdl-format]</code> section</a></h3>
<p>The currently supported entries are demonstrated in the following code snippet. Entries not present will be set to their default values.</p>
<pre><code class="language-toml">[vhdl-format]
# enable colored output for VHDL code snippets
highlight-syntax = true
# number of whitespace characters per tab/indentation
tab-size = 2
# insert a tab before 'generic' and 'port' interface declarations
indent-interface = true
# automatically align a signal or constant's subtype with its other identifiers
type-auto-alignment = false
# number of whitespace characters after alignment (before the `:` character)
type-offset = 0
# automatically align an instantiation's mapping along its port connections
mapping-auto-alignment = false
# number of whitespace characters before port connection (before the `=&gt;` character)
mapping-offset = 1
# the default instance name
instance-name = "uX"
</code></pre>
<h3 id="the-verilog-format-section"><a class="header" href="#the-verilog-format-section">The <code>[verilog-format]</code> section</a></h3>
<p>The currently supported entries are demonstrated in the following code snippet. Entries not present will be set to their default values. This section currently applies its settings to SystemVerilog and Verilog source code.</p>
<pre><code class="language-toml">[verilog-format]
# enable colored output for code snippets (TODO)
highlight-syntax = false
# number of whitespace characters per tab/indentation
tab-size = 2
# automatically align a port or parameter's name with the module's other names
name-auto-alignment = false
# number of additional whitespace characters after alignment
name-alignmnet = 0
# number of whitespaces before a range specifier
range-offset = 0
# automatically align an instantiation's mapping along its port connections
mapping-auto-alignment = false
# number of whitespace characters before port connection (before the `(` character)
mapping-offset = 0
# the default instance name
instance-name = "uX"
</code></pre>
<h3 id="the-env-section"><a class="header" href="#the-env-section">The <code>[env]</code> section</a></h3>
<p>The user can define an arbitrary number of their own entries with their determined value represented in string format.</p>
<pre><code class="language-toml">[env]
foo = "0" # Accessible as ORBIT_ENV_FOO
super-bar = "1" # Accessible as ORBIT_ENV_SUPER_BAR
</code></pre>
<h3 id="the-target-array"><a class="header" href="#the-target-array">The <code>[[target]]</code> array</a></h3>
<h3 id="the-name-field-1"><a class="header" href="#the-name-field-1">The <code>name</code> field</a></h3>
<pre><code class="language-toml">[[target]]
name = "dump-blueprint"
</code></pre>
<h3 id="the-description-field-1"><a class="header" href="#the-description-field-1">The <code>description</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
description = "Print the blueprint contents to the screen"
</code></pre>
<h3 id="the-command-field"><a class="header" href="#the-command-field">The <code>command</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
command = "cat"
</code></pre>
<h3 id="the-args-field"><a class="header" href="#the-args-field">The <code>args</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
args = ["blueprint.tsv"]
</code></pre>
<h3 id="the-plans-field"><a class="header" href="#the-plans-field">The <code>plans</code> field</a></h3>
<pre><code class="language-toml">[[target]]
# ...
plans = ["tsv"]
</code></pre>
<p>The type of blueprint files supported by the particular target. If a list is provided, the default plan used is the first item in the list. If a plan is provided on the command-line, then it must be a valid plan and found within the target's defined list.</p>
<p>If this field is left blank or not defined, then the default plan is "tsv".</p>
<h3 id="the-fileset-section"><a class="header" href="#the-fileset-section">The <code>[fileset]</code> section</a></h3>
<pre><code class="language-toml">[[target]]
# ...
fileset.pymdl = "{{ orbit.bench }}.py"
</code></pre>
<h3 id="the-protocol-array"><a class="header" href="#the-protocol-array">The <code>[[protocol]]</code> array</a></h3>
<h3 id="the-name-field-2"><a class="header" href="#the-name-field-2">The <code>name</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-description-field-2"><a class="header" href="#the-description-field-2">The <code>description</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-command-field-1"><a class="header" href="#the-command-field-1">The <code>command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-args-field-1"><a class="header" href="#the-args-field-1">The <code>args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-channel-array"><a class="header" href="#the-channel-array">The <code>[[channel]]</code> array</a></h3>
<h3 id="the-name-field-3"><a class="header" href="#the-name-field-3">The <code>name</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-description-field-3"><a class="header" href="#the-description-field-3">The <code>description</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-root-field"><a class="header" href="#the-root-field">The <code>root</code> field</a></h3>
<p>The file system path where the channel exists, relative to the configuration file where it is defined.</p>
<pre><code class="language-toml">[[channel]]
# ...
root = "./index"
</code></pre>
<h3 id="the-synccommand-field"><a class="header" href="#the-synccommand-field">The <code>sync.command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-syncargs-field"><a class="header" href="#the-syncargs-field">The <code>sync.args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-precommand-field"><a class="header" href="#the-precommand-field">The <code>pre.command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-preargs-field"><a class="header" href="#the-preargs-field">The <code>pre.args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-postcommand-field"><a class="header" href="#the-postcommand-field">The <code>post.command</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<h3 id="the-postargs-field"><a class="header" href="#the-postargs-field">The <code>post.args</code> field</a></h3>
<p>See <a href="reference/configuration.html#the-target-array">[target]</a>'s definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-output"><a class="header" href="#json-output">JSON Output</a></h1>
<p>The <code>orbit get</code> command allows a user to receive various pieces of information related to a design unit, such its component declaration, defined architectures, or entity instantiation.</p>
<p>It also allows users to export the unit's interface with the <code>--json</code> flag. This is convenient when you wish to pass this information in a more machine-readable format to another tool/program.</p>
<p>The serialized JSON data is also available during the execution phase of a build process through the appropriate environment variables. To know which variables contain this data, see <a href="reference/./environment_variables.html">Environment Variables</a>.</p>
<p>The serialized JSON string data is unformatted.</p>
<h2 id="schema"><a class="header" href="#schema">Schema</a></h2>
<p>The following schema is implemented for the json output:</p>
<pre><code class="language-json">{
  "identifier": string
  "generics": [
    {
        "identifier": string
        "mode": string
        "type": string // null if blank
        "default": string // null if blank
    }
  ]
  "ports": [
    {
        "identifier": string
        "mode": string
        "type": string // null if blank
        "default": string // null if blank
    }
  ]
  "architectures": [
      string
  ],
  "language": string
}
</code></pre>
<p>The "language" field is allowed to be one of three values: "vhdl", "verilog", or "systemverilog".</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Some ideas about exporting json from <code>orbit get</code> can be found at this <a href="https://blog.kellybrazil.com/2021/12/03/tips-on-adding-json-output-to-your-cli-app/">blog post</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line"><a class="header" href="#command-line">Command line</a></h1>
<p>The command line is the main way of interacting with <code>orbit</code>. Let's understand some terminology and rules for communicating to <code>orbit</code> through the command line.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Angular brackets (<code>&lt; &gt;</code>) denotes that a user input is required. The label within the angular brackets gives a hint to the user as to what type of value to enter here.</p>
<p>Square brackets (<code>[ ]</code>) denotes that the input is optional and is not required to get the command to successfully run.</p>
<h2 id="jargon"><a class="header" href="#jargon">Jargon</a></h2>
<p>Orbit uses <em>subcommands</em>, <em>arguments</em>, <em>options</em>, <em>flags</em>, and <em>switches</em>.</p>
<h3 id="subcommand"><a class="header" href="#subcommand"><strong>Subcommand</strong></a></h3>
<p>Subcommands are special keywords to route to a particular action. Each subcommand inherits all supercommand's available options. They are the first positional argument following the call to <code>orbit</code>.</p>
<pre><code>orbit get
</code></pre>
<h3 id="argument"><a class="header" href="#argument"><strong>Argument</strong></a></h3>
<p>An argument is a value interpreted based on its position in the input. Arguments must be included when requested by Orbit within angular brackets (<code>&lt; &gt;</code>).</p>
<pre><code>orbit new &lt;path&gt;
</code></pre>
<p>Arguments may be omitted if they are wrapped with square brackets (<code>[ ]</code>).</p>
<pre><code>orbit search [&lt;ip&gt;]
</code></pre>
<h3 id="flag"><a class="header" href="#flag"><strong>Flag</strong></a></h3>
<p>A flag is a simple boolean on-off conditional to alter a command's behavior, that is true when present and false otherwise.</p>
<pre><code>--help
</code></pre>
<p>Flags are options that do not take an argument and can be omitted.</p>
<h3 id="option"><a class="header" href="#option"><strong>Option</strong></a></h3>
<p>An option is a type of flag that, when provided, is required to have an argument assigned to it. The argument may immediately proceed the option's flag separated by whitespace.</p>
<pre><code>--plugin &lt;name&gt;
</code></pre>
<p>The argument may also be attached to the option's flag with an equal sign <code>=</code>.</p>
<pre><code>--plugin=&lt;name&gt;
</code></pre>
<p>Options are able to be omitted.</p>
<h3 id="switch"><a class="header" href="#switch"><strong>Switch</strong></a></h3>
<p>A switch is a shorthand flag denoted by a single dash and a single character.</p>
<pre><code>-h
</code></pre>
<p>Multiple switches can be chained onto the same dash.</p>
<pre><code>-ci
</code></pre>
<p>If a switch is associated with an option, it must be declared last on a chain with its argument to immediately follow separated by whitespace or an equal sign <code>=</code>.</p>
<pre><code>-o &lt;file&gt;
</code></pre>
<p>Common flags and options may have a shorthand <em>switch</em> associated with them. For example, <code>--help</code> can be alternatively passed with just <code>-h</code>.</p>
<h3 id="argument-terminator"><a class="header" href="#argument-terminator"><strong>Argument terminator</strong></a></h3>
<p>The argument terminator is a special no-op flag <code>--</code> that tells the command-line interpreter to parse up until this symbol.</p>
<p>Some scenarios will allow you to pass arguments through <code>orbit</code> to an internally executed command. You can pass these arguments by using the <em>argument terminator</em>.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<p>An example of using the argument terminator is brought up when calling a plugin through <code>orbit</code> during the building step.</p>
<pre><code>$ orbit build --plugin yilinx -- --sram
</code></pre>
<p>In this command, <code>orbit</code> does not interpret the "--sram" flag, but instead passes it to the plugin named "yilinx" to handle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Commands are loosely grouped into two types: development and management. Commands used for development often operate on your local ip. Commands used for management often use Orbit to gain insight into external ip found in the catalog.</p>
<p>The commands are listed below in their group and in a typical order of usage for a possible workflow.</p>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<ul>
<li><a href="commands/./new.html">orbit new</a></li>
<li><a href="commands/./init.html">orbit init</a></li>
<li><a href="commands/./read.html">orbit read</a></li>
<li><a href="commands/./get.html">orbit get</a></li>
<li><a href="commands/./tree.html">orbit tree</a></li>
<li><a href="commands/./lock.html">orbit lock</a></li>
<li><a href="commands/./test.html">orbit test</a></li>
<li><a href="commands/./build.html">orbit build</a></li>
</ul>
<h2 id="management"><a class="header" href="#management">Management</a></h2>
<ul>
<li><a href="commands/./search.html">orbit search</a></li>
<li><a href="commands/./info.html">orbit info</a></li>
<li><a href="commands/./install.html">orbit install</a></li>
<li><a href="commands/./publish.html">orbit publish</a></li>
<li><a href="commands/./download.html">orbit download</a></li>
<li><a href="commands/./remove.html">orbit remove</a></li>
<li><a href="commands/./config.html">orbit config</a></li>
<li><a href="commands/./env.html">orbit env</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-new"><a class="header" href="#orbit-new"><strong>orbit new</strong></a></h1>
<h2 id="name-1"><a class="header" href="#name-1"><strong>NAME</strong></a></h2>
<p>new - create a new ip</p>
<h2 id="synopsis"><a class="header" href="#synopsis"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit new [options] &lt;path&gt;
</code></pre>
<h2 id="description"><a class="header" href="#description"><strong>DESCRIPTION</strong></a></h2>
<p>Creates a new ip at the target directory <code>&lt;path&gt;</code>. The path is assumed to not
already exist. A new directory will be created at the file system destination
that contains a minimal manifest file.</p>
<p>If no name is supplied, then the ip's name defaults to the final directory name
taken from <code>&lt;path&gt;</code>. Using the <code>--name</code> option allows this field to be
explicitly set.</p>
<p>The newly created manifest file is intended to be edited by the user. See more
<code>Orbit.toml</code> keys and their definitions at:</p>
<p>https://chaseruskin.github.io/orbit/reference/manifest.html</p>
<p>For initializing an already existing project into an ip, see the <code>init</code>
command.</p>
<h2 id="options"><a class="header" href="#options"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
            Directory to create for the ip</p>
<p><code>--name &lt;name&gt;</code><br />
            Set the resulting ip's name</p>
<p><code>--lib &lt;lib&gt;</code><br />
            Set the resulting ip's library</p>
<h2 id="examples-2"><a class="header" href="#examples-2"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit new gates
orbit new eecs/lab1 --name adder
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-init"><a class="header" href="#orbit-init"><strong>orbit init</strong></a></h1>
<h2 id="name-2"><a class="header" href="#name-2"><strong>NAME</strong></a></h2>
<p>init - initialize an ip from an existing project</p>
<h2 id="synopsis-1"><a class="header" href="#synopsis-1"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit init [options] [&lt;path&gt;]
</code></pre>
<h2 id="description-1"><a class="header" href="#description-1"><strong>DESCRIPTION</strong></a></h2>
<p>Initializes an ip at the file system directory <code>&lt;path&gt;</code>. If not path is
provided, then it defaults to the current working directory.</p>
<p>If no name is provided, then the resulting ip's name defaults to the
directory's name. Using the <code>--name</code> option allows the ip's name to be
explicitly set.</p>
<p>Under certain circumstances, you may need a new uuid. This situation will be
uncommon for many users, but nonetheless it exists. To display a new uuid that
can be copied into an existing manifest, use the <code>--uuid</code> option. All other
options are ignored when this option is present. Keep in mind that an ip's uuid
is not intended to change over the course of its lifetime.</p>
<p>The newly created manifest file is intended to be edited by the user. See more
<code>Orbit.toml</code> keys and their definitions at:</p>
<p>https://chaseruskin.github.io/orbit/reference/manifest.html</p>
<p>To create a new ip from a non-existing directory, see the <code>new</code> command.</p>
<h2 id="options-1"><a class="header" href="#options-1"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
            Directory to initialize</p>
<p><code>--name &lt;name&gt;</code><br />
            Set the resulting ip's name</p>
<p><code>--lib &lt;lib&gt;</code><br />
            Set the resulting ip's library</p>
<p><code>--uuid</code><br />
            Print a new uuid and exit</p>
<h2 id="examples-3"><a class="header" href="#examples-3"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit init
orbit init projects/gates
orbit init --name adder
orbit init --uuid
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-info"><a class="header" href="#orbit-info"><strong>orbit info</strong></a></h1>
<h2 id="name-3"><a class="header" href="#name-3"><strong>NAME</strong></a></h2>
<p>info - display information about an ip</p>
<h2 id="synopsis-2"><a class="header" href="#synopsis-2"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit info [options] [&lt;ip&gt;]
</code></pre>
<h2 id="description-2"><a class="header" href="#description-2"><strong>DESCRIPTION</strong></a></h2>
<p>Displays various bits of information about a particular ip. If no ip is
provided, then it displays information related to the local ip.</p>
<p>To display manifest information, no additional options are required.</p>
<p>To display the defined HDL design elements within the ip, use the <code>--units</code>
option. For non-local ip, its protected and private design elements are hidden
from the results. To display design elements of all visibility levels the
<code>--all</code> option must also be present.</p>
<p>To display the known versions for an ip, use the <code>--versions</code> option.</p>
<h2 id="options-2"><a class="header" href="#options-2"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
            Ip specification</p>
<p><code>--versions, -v</code><br />
            Display the list of known versions</p>
<p><code>--units, -u</code><br />
            Display the hdl design elements defined for this ip</p>
<p><code>--all, -a</code><br />
            Include any private or hidden results</p>
<h2 id="examples-4"><a class="header" href="#examples-4"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit info --units
orbit info gates:1.0.0 -u --all
orbit info gates --versions
orbit info gates:1 -v
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-read"><a class="header" href="#orbit-read"><strong>orbit read</strong></a></h1>
<h2 id="name-4"><a class="header" href="#name-4"><strong>NAME</strong></a></h2>
<p>read - lookup hdl source code</p>
<h2 id="synopsis-3"><a class="header" href="#synopsis-3"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit read [options] &lt;unit&gt;
</code></pre>
<h2 id="description-3"><a class="header" href="#description-3"><strong>DESCRIPTION</strong></a></h2>
<p>Navigates hdl source code to lookup requested hdl code snippets. Looking up
hdl source code to see its implementation can help gain a better understanding
of the code being reused in your current design.</p>
<p>By default, the resulting code is displayed to the console. To write the
results to a file for improved readability, use the <code>--save</code> option. Combining
the <code>--locate</code> option with the <code>--save</code> option will append the line and column
number of the identified code snippet to the end of the resulting file path.</p>
<p>If no ip is provided by the <code>--ip</code> option, then it will assume to search the
local ip for the provided design unit.</p>
<p>The values for options <code>--start</code>, <code>--end</code>, and <code>--doc</code> must be valid hdl code.
The code is interpreted in the native language of the provided design unit.</p>
<p>The <code>--doc</code> option will attempt to find the comments immediately preceding the
identified code snippet.</p>
<p>A design unit must visible in order for it to return the respective source
code. When reading a design unit that exists within the local ip, it can be
any visibility. When reading a design unit that exists outside of the
local ip, its visibility must be "public" or "protected". Design units that
are set to "private" visibility are not allowed to be read outside of their
ip.</p>
<p>Every time this command is called, it attempts to clean the temporary
directory where it saves resulting files. To keep existing files on the next
call of this command, use the <code>--no-clean</code> option.</p>
<h2 id="options-3"><a class="header" href="#options-3"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;</code><br />
            Read the file for this primary design unit</p>
<p><code>--ip &lt;spec&gt;</code><br />
            Ip specification</p>
<p><code>--doc &lt;code&gt;</code><br />
            Find the preceding comments to the code snippet</p>
<p><code>--save</code><br />
            Write the results to a temporary read-only file</p>
<p><code>--start &lt;code&gt;</code><br />
            Start the lookup after jumping to this code snippet</p>
<p><code>--end &lt;code&gt;</code><br />
            Stop the lookup after finding this code snippet</p>
<p><code>--limit &lt;n&gt;</code><br />
            Maximum number of source code lines to return</p>
<p><code>--no-clean</code><br />
            Do not clean the temporary directory of existing files</p>
<p><code>--locate</code><br />
            Append the line and column number to the resulting file</p>
<h2 id="examples-5"><a class="header" href="#examples-5"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit read and_gate --limit 25
orbit read math_pkg --ip math --doc "function clog2" --start "package math_pkg"
orbit read math_pkg --ip math --doc "function flog2p1" --save --locate
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-get"><a class="header" href="#orbit-get"><strong>orbit get</strong></a></h1>
<h2 id="name-5"><a class="header" href="#name-5"><strong>NAME</strong></a></h2>
<p>get - fetch an hdl unit for code integration</p>
<h2 id="synopsis-4"><a class="header" href="#synopsis-4"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit get [options] &lt;unit&gt;
</code></pre>
<h2 id="description-4"><a class="header" href="#description-4"><strong>DESCRIPTION</strong></a></h2>
<p>Returns hdl code snippets for the provided design unit to be integrated into
the current design. The code snippets are returned in the native hdl
language of the identified design unit. Code snippets are designed to be
copy and pasted from the console to the current design for quick code
integration.</p>
<p>If an ip is not provided with the <code>--ip</code> option, then it will search the local
ip for the requested design unit.</p>
<p>If the design unit is in VHDL with the <code>--instance</code> option being used without
the <code>--component</code> option, then it will return the direct instantiation code
style (VHDL-93 feature).</p>
<p>Copying unit instantiations into higher-level entities will not
automatically track source code references across ips. In order to properly
establish source code reference tracking across ips, the local ip's manifest
must have an up to date <code>[dependencies]</code> table that lists all the ips from
which it references source code.</p>
<p>An identifier prefix or suffix can be attached to the signal declarations and
the instantiation's port connection signals by using <code>--signal-prefix</code> and
<code>--signal-suffix</code> respectively. These optional texts are treated as normal
strings and are not checked for correct hdl coding syntax.</p>
<p>When no output options are specified, this command by default will display
the unit's declaration.</p>
<p>A design unit must visible in order for it to return the respective code
snippets. When fetching a design unit that exists within the local ip, it
can be any visibility. When fetching a design unit that exists outside of the
local ip, its visibility must be "public". Design units that are set to
"protected" or "private" visibility are not allowed to be referenced across
ips.</p>
<p>Exporting the unit's declaration information can be accomplished by using the
<code>--json</code> option. The valid json is unformatted for encouragement to be
processed by other programs.</p>
<p>By default, the code snippets will be displayed in the design unit's native
hardware description language. To return the code snippets in a particular
language, use the <code>--language</code> option. Valid values are "vhdl", "sv", or
"native".</p>
<h2 id="options-4"><a class="header" href="#options-4"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;</code><br />
            Primary design unit identifier</p>
<p><code>--ip &lt;spec&gt;</code><br />
            Ip specification</p>
<p><code>--json</code><br />
            Export the unit's information as valid json</p>
<p><code>--library, -l</code><br />
            Display the unit's library declaration</p>
<p><code>--component, -c</code><br />
            Display the unit's declaration</p>
<p><code>--signals, -s</code><br />
            Display the constant and signal declarations</p>
<p><code>--instance, -i</code><br />
            Display the unit's instantiation</p>
<p><code>--language &lt;hdl&gt;</code><br />
            Display in the specified language (vhdl, sv, native)</p>
<p><code>--architecture, -a</code><br />
            Display the unit's architectures</p>
<p><code>--name &lt;identifier&gt;</code><br />
            Set the instance's identifier</p>
<p><code>--signal-prefix &lt;str&gt;</code><br />
            Prepend information to the instance's signals</p>
<p><code>--signal-suffix &lt;str&gt;</code><br />
            Append information to the instance's signals</p>
<h2 id="examples-6"><a class="header" href="#examples-6"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit get and_gate --ip gates:1.0.0 --component
orbit get ram --ip mem:2 -csi
orbit get uart -si --name uart_inst0
orbit get or_gate --ip gates --json
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-tree"><a class="header" href="#orbit-tree"><strong>orbit tree</strong></a></h1>
<h2 id="name-6"><a class="header" href="#name-6"><strong>NAME</strong></a></h2>
<p>tree - show the dependency graph</p>
<h2 id="synopsis-5"><a class="header" href="#synopsis-5"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit tree [options] [&lt;unit&gt;...]
</code></pre>
<h2 id="description-5"><a class="header" href="#description-5"><strong>DESCRIPTION</strong></a></h2>
<p>Shows the hierarchical tree structure of the hardware design starting from a
root node.</p>
<p>By default, it will try to automatically detect the root node for the
local ip. If there is ambiguity in determining what node can be the root, then
all root nodes and their respective trees will be displayed. To only display
the tree of a particular node, use the <code>&lt;unit&gt;</code> option.</p>
<p>The tree can display different kinds of dependencies relative to the current
ip using the <code>--edges</code> option. By default, this command uses "unit". By
specifying edges as "ip", it will return the ip-level dependency tree. When
using "unit" or "all", the hdl dependency graph will be displayed. The hdl
graph shown with "unit" displays the composition of usable entities/modules.
To generate this graph, it analyzes each VHDL architecture and ignores Verilog
compiler directives. If an unidentified entity is instantiated, it will appear
as a leaf in the graph and will be considered as a "black box" denoted by
the "?" character next to its position in the tree. The hdl graph shown with
"all" displays the composition of the design including all primary design unit
references. Any references (excluding entity instantiations) that are not
found will not appear in the dependency graph for the "all" option.</p>
<p>Using the <code>--format</code> option can alter how much information is displayed for
each hdl design unit in the tree composition. By default, only the design
unit's name is displayed for each unit.</p>
<p>To display the ip dependency graph, use the <code>--ip</code> option.</p>
<p>If the tree's character output is not displaying properly, then the tree can
be displayed using a set of standard ASCII characters with the <code>--ascii</code>
option.</p>
<h2 id="options-5"><a class="header" href="#options-5"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;unit&gt;...</code><br />
            Uppermost hdl unit of the dependency tree</p>
<p><code>--edges, -e &lt;kind&gt;</code><br />
            The kind of dependencies to display (unit, ip, all)</p>
<p><code>--format &lt;fmt&gt;</code><br />
            Determine how to display nodes (long, short)</p>
<p><code>--ascii</code><br />
            Limit the textual tree characters to the 128 ascii set</p>
<h2 id="examples-7"><a class="header" href="#examples-7"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit tree
orbit tree top --format long
orbit tree -e ip --ascii
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-lock"><a class="header" href="#orbit-lock"><strong>orbit lock</strong></a></h1>
<h2 id="name-7"><a class="header" href="#name-7"><strong>NAME</strong></a></h2>
<p>lock - save the world state of an ip</p>
<h2 id="synopsis-6"><a class="header" href="#synopsis-6"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit lock [options]
</code></pre>
<h2 id="description-6"><a class="header" href="#description-6"><strong>DESCRIPTION</strong></a></h2>
<p>Saves the state of the world for the local ip. To accomplish this, Orbit reads
the local ip's manifest file, "Orbit.toml", to resolve any missing ip
dependencies. It writes the information required to reproduce this state to
the ip's lock file, "Orbit.lock".</p>
<p>A local ip must exist for this command to execute.</p>
<p>It is encouraged to check the lock file into version control such that other
users trying to reconstruct the ip can reproduce the ip's current state. The
lock file should not be manually edited by the user.</p>
<p>To capture the world state for the local ip, Orbit downloads and installs any
unresolved ip dependencies. If an installed dependency's computed checksum
does not match the checksum stored in the lock file, it assumes the
installation is corrupt and will reinstall the dependency to the cache.</p>
<h2 id="options-6"><a class="header" href="#options-6"><strong>OPTIONS</strong></a></h2>
<p><code>--force</code><br />
            Ignore reading the precomputed lock file</p>
<h2 id="examples-8"><a class="header" href="#examples-8"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit lock
orbit lock --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-test"><a class="header" href="#orbit-test"><strong>orbit test</strong></a></h1>
<h2 id="name-8"><a class="header" href="#name-8"><strong>NAME</strong></a></h2>
<p>test - run a test</p>
<h2 id="synopsis-7"><a class="header" href="#synopsis-7"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit test [options] [--] [args]...
</code></pre>
<h2 id="description-7"><a class="header" href="#description-7"><strong>DESCRIPTION</strong></a></h2>
<p>This command prepares a given target and then executes the target.</p>
<p>While this command functions similar to <code>orbit build</code>, the targets that are
encouraged to be used with this command are ones that are designed to either
"pass" or "fail", typically through a return code. This command requires a
testbench, if you do not want to set a testbench, see <code>orbit build</code>.</p>
<p>A target must be provided for the test command to run. A default target can
be specified in a configuration file, which will be used when a target is
omitted from the command-line.</p>
<p>If <code>--list</code> is used, then it will display a list of the available targets to
the user. Using <code>--list</code> in combination with a target from <code>--target</code> will
display any detailed help information the target has documented in its
definition.</p>
<p>A target typically goes through three steps for the testing process:</p>
<ol>
<li>Parse the blueprint file</li>
<li>Process the referenced files listed in the blueprint</li>
<li>Verify the hdl source code passes all tests</li>
</ol>
<p>Any command-line arguments entered after the terminating flag <code>--</code> will be
passed in the received order as arguments to the subprocess's command. If a
target already has defined arguments, the additional arguments passed from the
command-line will follow the previously defined arguments.</p>
<p>The target's process will spawn from the current working ip's output directory,
which is $ORBIT_TARGET_DIR/$ORBIT_TARGET.</p>
<h2 id="options-7"><a class="header" href="#options-7"><strong>OPTIONS</strong></a></h2>
<p><code>--target, -t &lt;name&gt;</code><br />
            Target to execute</p>
<p><code>--dut &lt;unit&gt;</code><br />
            Set the device under test</p>
<p><code>--tb &lt;unit&gt;</code><br />
            Set the top level testbench unit</p>
<p><code>--plan &lt;format&gt;</code><br />
            Set the blueprint file format</p>
<p><code>--target-dir &lt;dir&gt;</code><br />
            The relative directory where the target starts</p>
<p><code>--command &lt;path&gt;</code><br />
            Overwrite the target's command</p>
<p><code>--list</code><br />
            View available targets and exit</p>
<p><code>--all</code><br />
            Include all hdl files of the working ip</p>
<p><code>--fileset &lt;key=glob&gt;...</code><br />
            A glob-style pattern identified by name to include in the blueprint</p>
<p><code>--no-clean</code><br />
            Do not clean the target folder before execution</p>
<p><code>--force</code><br />
            Force the target to execute</p>
<p><code>--verbose</code><br />
            Display the command being executed</p>
<p><code>args</code><br />
            Arguments to pass to the target</p>
<h2 id="examples-9"><a class="header" href="#examples-9"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit test --dut adder --tb adder_tb --target modelsim -- --lint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-build"><a class="header" href="#orbit-build"><strong>orbit build</strong></a></h1>
<h2 id="name-9"><a class="header" href="#name-9"><strong>NAME</strong></a></h2>
<p>build - plan and execute a target</p>
<h2 id="synopsis-8"><a class="header" href="#synopsis-8"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit build [options] [--] [args]...
</code></pre>
<h2 id="description-8"><a class="header" href="#description-8"><strong>DESCRIPTION</strong></a></h2>
<p>This command prepares a given target and then executes the target.</p>
<p>While this command functions similar to <code>orbit test</code>, the targets that are
encouraged to be used with this command are ones that produce artifacts at the
end of their execution process. This command does not allow the top to be a
testbench, if you want to set a testbench, see <code>orbit test</code>.</p>
<p>A target must be provided for the build command to run. A default target can
be specified in a configuration file, which will be used when a target is
omitted from the command-line.</p>
<p>If <code>--list</code> is used, then it will display a list of the available targets to
the user. Using <code>--list</code> in combination with a target from <code>--target</code> will
display any detailed help information the target has documented in its
definition.</p>
<p>A target typically goes through three steps for the building process:</p>
<ol>
<li>Parse the blueprint file</li>
<li>Process the referenced files listed in the blueprint</li>
<li>Generate a artifact(s)</li>
</ol>
<p>Any command-line arguments entered after the terminating flag <code>--</code> will be
passed in the received order as arguments to the subprocess's command. If a
target already has defined arguments, the additional arguments passed from the
command-line will follow the previously defined arguments.</p>
<p>The target's process will spawn from the current working ip's output directory,
which is $ORBIT_TARGET_DIR/$ORBIT_TARGET.</p>
<h2 id="options-8"><a class="header" href="#options-8"><strong>OPTIONS</strong></a></h2>
<p><code>--target, -t &lt;name&gt;</code><br />
            Target to execute</p>
<p><code>--top &lt;unit&gt;</code><br />
            Set the top level design unit</p>
<p><code>--plan &lt;format&gt;</code><br />
            Set the blueprint file format</p>
<p><code>--target-dir &lt;dir&gt;</code><br />
            The relative directory where the target starts</p>
<p><code>--command &lt;path&gt;</code><br />
            Overwrite the target's command</p>
<p><code>--list</code><br />
            View available targets and exit</p>
<p><code>--all</code><br />
            Include all hdl files of the working ip</p>
<p><code>--fileset &lt;key=glob&gt;...</code><br />
            A glob-style pattern identified by name to include in the blueprint</p>
<p><code>--force</code><br />
            Force the target to execute</p>
<p><code>--no-clean</code><br />
            Do not clean the target folder before execution</p>
<p><code>--verbose</code><br />
            Display the command being executed</p>
<p><code>args</code><br />
            Arguments to pass to the target</p>
<h2 id="examples-10"><a class="header" href="#examples-10"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit build --target xsim -- --elab
orbit build --command python3 --target pysim
orbit build --all --target-dir build --target ghdl
orbit build --target xsim --force -- --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-publish"><a class="header" href="#orbit-publish"><strong>orbit publish</strong></a></h1>
<h2 id="name-10"><a class="header" href="#name-10"><strong>NAME</strong></a></h2>
<p>publish - post an ip to a channel</p>
<h2 id="synopsis-9"><a class="header" href="#synopsis-9"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit publish [options]
</code></pre>
<h2 id="description-9"><a class="header" href="#description-9"><strong>DESCRIPTION</strong></a></h2>
<p>Performs a series of checks for a local ip and then releases it to its
specified channel(s).</p>
<p>There are multiple checks that are performed before an ip can be published.
First, the ip must have an up to date lockfile with no relative dependencies.
The ip's manifest must also have a value for the source field. In addition,
Orbit must be able to construct the hdl source code graph without errors.
Finally, the ip is downloaded from its source url and temporarily installed
to verify its contents match those of the local ip.</p>
<p>Posting an ip to a channel involves copying the ip's manifest file to a path
within the channel known as the index. For every publish of an ip, the index
corresponds to a unique path within the channel that gets created by Orbit.
A channel's pre-publish and post-publish hooks can get the value for the ip's
index by reading the ORBIT_IP_INDEX environment variable.</p>
<p>By default, this command performs a dry run, which executes all of the steps
in the process except for actually posting the ip to its channel(s).
To run the command to completion, use the <code>--ready</code> option.</p>
<h2 id="options-9"><a class="header" href="#options-9"><strong>OPTIONS</strong></a></h2>
<p><code>--ready, -y</code><br />
            Run the operation to completion</p>
<p><code>--no-install</code><br />
            Do not install the ip for future use</p>
<p><code>--list</code><br />
            View available channels and exit</p>
<h2 id="examples-11"><a class="header" href="#examples-11"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit publish
orbit publish --ready
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-search"><a class="header" href="#orbit-search"><strong>orbit search</strong></a></h1>
<h2 id="name-11"><a class="header" href="#name-11"><strong>NAME</strong></a></h2>
<p>search - browse the ip catalog</p>
<h2 id="synopsis-10"><a class="header" href="#synopsis-10"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit search [options] [&lt;ip&gt;]
</code></pre>
<h2 id="description-10"><a class="header" href="#description-10"><strong>DESCRIPTION</strong></a></h2>
<p>Returns a list of the ip found in the catalog.</p>
<p>By default, all ip in the catalog will be returned. To filter by ip name, use
the <code>&lt;ip&gt;</code> option. To limit the number of results, use the <code>--limit</code> option.</p>
<p>An ip can be stored across three different levels: installed in the cache,
downloaded to the archive, and available via channels. By default, all levels
are searched for ip. Applying a level filter (<code>--install</code>, <code>--download</code>,
<code>--available</code> options) will restrict the search to only checking the filtered
levels for ip.</p>
<p>A resulting ip is only read from one level, even when multiple levels are
searched. When an ip exists at multiple levels, the catalog imposes a priority
on which level to choose. Installed ip have higher priority over downloaded ip,
and downloaded ip have higher priority over available ip.</p>
<p>Results can also be filtered by keyword using the <code>--keyword</code> option. By
default, if an ip matches at least one filter then it will be returned in the
result. To collect only ip that match each presented filter, use the <code>--match</code>
option.</p>
<p>If an ip has a higher version that exists and is not currently installed, then
an asterisk character "*" will appear next the ip's version. To update the ip
to the latest version, see the <code>install</code> command.</p>
<h2 id="options-10"><a class="header" href="#options-10"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
            Ip's name</p>
<p><code>--install, -i</code><br />
            Filter ip installed to the cache</p>
<p><code>--download, -d</code><br />
            Filter ip downloaded to the archive</p>
<p><code>--available, -a</code><br />
            Filter ip available via channels</p>
<p><code>--keyword &lt;term&gt;...</code><br />
            Include ip that have this keyword</p>
<p><code>--limit &lt;n&gt;</code><br />
            Maximum number of results to return</p>
<p><code>--match</code><br />
            Return results that pass each filter</p>
<h2 id="examples-12"><a class="header" href="#examples-12"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit search axi
orbit search --keyword memory --keyword ecc
orbit search --keyword cdc --limit 20 -i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-install"><a class="header" href="#orbit-install"><strong>orbit install</strong></a></h1>
<h2 id="name-12"><a class="header" href="#name-12"><strong>NAME</strong></a></h2>
<p>install - store an immutable reference to an ip</p>
<h2 id="synopsis-11"><a class="header" href="#synopsis-11"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit install [options]
</code></pre>
<h2 id="description-11"><a class="header" href="#description-11"><strong>DESCRIPTION</strong></a></h2>
<p>This command will place an ip into the cache. By default, the specified version
is the 'latest' released version orbit can identify.</p>
<p>When this command is ran without specifying the <ip> or a source (such as
<code>--url</code> or <code>--path</code>), it will attempt to install the current working ip, if it
exists.</p>
<p>By default, any dependencies required only for development by the target ip are
omitted from installation. To also install these dependencies, use <code>--all</code>.</p>
<p>If a protocol is recognized using <code>--protocol</code>, then an optional tag can also
be supplied to help the protocol with providing any additional information it
may require.</p>
<p>The <code>--path</code> command can accept a file system path that is either 1) the root
directory that contains the manifest file or 2) a zip archive file that when
uncompressed, has the manifest file at the root directoy.</p>
<p>To remove ip from the catalog, see the <code>remove</code> command.</p>
<h2 id="options-11"><a class="header" href="#options-11"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
            Ip specification</p>
<p><code>--url &lt;url&gt;</code><br />
            Url to install the ip from the internet</p>
<p><code>--path &lt;path&gt;</code><br />
            Path to install the ip from local file system</p>
<p><code>--protocol &lt;name&gt;</code><br />
            Use a configured protocol to download ip</p>
<p><code>--tag &lt;tag&gt;</code><br />
            Unique tag to provide to the protocol</p>
<p><code>--force</code><br />
            Install the ip regardless of the cache slot occupancy</p>
<p><code>--offline</code><br />
            Skip checking coherency with source</p>
<p><code>--list</code><br />
            View available protocols and exit</p>
<p><code>--all</code><br />
            Install all dependencies (including development)</p>
<h2 id="examples-13"><a class="header" href="#examples-13"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit install
orbit install lcd_driver:2.0
orbit install adder:1.0.0 --url https://my.adder/project.zip
orbit install alu:2.3.7 --path ./projects/alu --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-remove"><a class="header" href="#orbit-remove"><strong>orbit remove</strong></a></h1>
<h2 id="name-13"><a class="header" href="#name-13"><strong>NAME</strong></a></h2>
<p>remove - delete an ip from the catalog</p>
<h2 id="synopsis-12"><a class="header" href="#synopsis-12"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit remove [options] &lt;ip&gt;
</code></pre>
<h2 id="description-12"><a class="header" href="#description-12"><strong>DESCRIPTION</strong></a></h2>
<p>Deletes save data for a known ip from the catalog. The ip's data for its
particular version is removed from the catalog's cache and the catalog's
archive.</p>
<p>By default, an interactive prompt will appear to confirm with the user if the
correct ip is okay to be removed. To skip this interactive prompt and assume
it is correct without confirmation, use the <code>--force</code> option.</p>
<p>To add ip to the catalog, see the <code>install</code> command.</p>
<h2 id="options-12"><a class="header" href="#options-12"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;ip&gt;</code><br />
            Ip specification</p>
<p><code>--force</code><br />
            Skip interactive prompts</p>
<p><code>--verbose</code><br />
            Display where the removal occurs</p>
<h2 id="examples-14"><a class="header" href="#examples-14"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit remove gates
orbit remove gates:1.0.1 --force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-env"><a class="header" href="#orbit-env"><strong>orbit env</strong></a></h1>
<h2 id="name-14"><a class="header" href="#name-14"><strong>NAME</strong></a></h2>
<p>env - print orbit environment information</p>
<h2 id="synopsis-13"><a class="header" href="#synopsis-13"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit env [options]
</code></pre>
<h2 id="description-13"><a class="header" href="#description-13"><strong>DESCRIPTION</strong></a></h2>
<p>Displays environment variables as key-value pairs related to Orbit.</p>
<p>By default, this command prints information as a shell script. If one or more
variable names are given as arguments using <code>&lt;key&gt;</code>, then it will print the
value of each provided variable on its own line.</p>
<p>Environment information can change based on where the command is executed.</p>
<p>Environment variables that are known only at runtime are not displayed. Be
sure to review the documentation for a list of all environment variables set
by Orbit.</p>
<h2 id="options-13"><a class="header" href="#options-13"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;key&gt;...</code><br />
            Display this variable's value</p>
<h2 id="examples-15"><a class="header" href="#examples-15"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit env
orbit env ORBIT_HOME
orbit env ORBIT_MANIFEST_DIR ORBIT_IP_NAME
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orbit-config"><a class="header" href="#orbit-config"><strong>orbit config</strong></a></h1>
<h2 id="name-15"><a class="header" href="#name-15"><strong>NAME</strong></a></h2>
<p>config - modify configuration data</p>
<h2 id="synopsis-14"><a class="header" href="#synopsis-14"><strong>SYNOPSIS</strong></a></h2>
<pre><code>orbit config [options] [&lt;path&gt;]
</code></pre>
<h2 id="description-14"><a class="header" href="#description-14"><strong>DESCRIPTION</strong></a></h2>
<p>Provides an entry point to the current configuration data through the
command-line.</p>
<p>To list the configuration files that are currently being used, use the
<code>--list</code> option. The configuration files are sorted in order from highest
precedence to lowest precedence. This means values that are set in files
higher in the list overwrite values that may have existed from files lowering
in the list.</p>
<p>Providing the path of a configuration file using the <code>&lt;path&gt;</code> option will
limit the accessible data to only the data found in the file. If no path is
specified, then it will display the aggregated result of the current
configuration data from across all files in use.</p>
<p>If there are no options set to modify data, then the resulting configuration
data will be displayed.</p>
<p>To modify a field, the full key must be provided. Fields located inside
tables require decimal characters "." to delimit between the key names. Each
modified field is edited in the configuration file has the lowest precedence
and would allow the changes to take effect. Files that won't be edited are
configuration files that are included in the global config file. If the
field does not exist in any configuration level, then the field will be
modified at in the global config file.</p>
<p>When modifying data, additions are processed before deletions. This means all
<code>--push</code> options occur before <code>--pop</code> options, and all <code>--set</code> options occur
before <code>--unset</code> options. Not every configuration field can be edited through
the command-line. More complex fields may require manual edits by opening its
respective file.</p>
<h2 id="options-14"><a class="header" href="#options-14"><strong>OPTIONS</strong></a></h2>
<p><code>&lt;path&gt;</code><br />
            The destination to read/write configuration data</p>
<p><code>--push &lt;key=value&gt;...</code><br />
            Add a new value to a key's list</p>
<p><code>--pop &lt;key&gt;...</code><br />
            Remove the last value from a key's list</p>
<p><code>--set &lt;key=value&gt;...</code><br />
            Store the value as the key's entry</p>
<p><code>--unset &lt;key&gt;...</code><br />
            Delete the key's entry</p>
<p><code>--list</code><br />
            Print the list of configuration files and exit</p>
<h2 id="examples-16"><a class="header" href="#examples-16"><strong>EXAMPLES</strong></a></h2>
<pre><code>orbit config --push include="profiles/hyperspacelab"
orbit config ~/.orbit/config.toml --unset env.vivado_path
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="archive-1"><a class="header" href="#archive-1">Archive</a></h3>
<p>The archive is the location where compressed snapshots of a specific ip's version exist. The compressed ip files are unable to be referenced as dependencies, but they are able to be <em>installed</em> to the cache for usage. The ip's in the archvie are considered <em>downloaded</em>.</p>
<h3 id="blueprint-1"><a class="header" href="#blueprint-1">Blueprint</a></h3>
<p>A blueprint is a single file that lists all the necessary source files and auxiliary files for the build process of a particular target. The source files are listed in topologically-sorted order. The blueprint is generated by Orbit during the planning stage of the build process, and is typically immediately used as input to the execution stage of the build process.</p>
<p>A blueprint can store the information collected from the planning stage in different file formats, called schemes. The default scheme is tab-separated values (TSV).</p>
<h3 id="cache-1"><a class="header" href="#cache-1">Cache</a></h3>
<p>The cache is the location where immutable references to a specific ip's version exist. An ip's dependencies are referenced from the cache. The ip that are found at the cache level are considered <em>installed</em>.</p>
<h3 id="catalog-1"><a class="header" href="#catalog-1">Catalog</a></h3>
<p>The catalog is the user's entire space of currently known ip to Orbit. It consists of 3 main layers: cache, downloads, channels.</p>
<h3 id="channels-2"><a class="header" href="#channels-2">Channels</a></h3>
<p>The channels are a set of decentralized registries that store the manifests for versions of ip. No source code is stored in a channel, however, Orbit is able to use the manifest as means to <em>download</em> that ip to the archive for local filesystem access. The ip that are found at the channels level are considered <em>available</em>. Users are encouraged to create and share their own channels.</p>
<h3 id="fileset"><a class="header" href="#fileset">Fileset</a></h3>
<p>A fileset is a glob-style pattern for collecting files under a given name. Filesets are
used to group common files together into the blueprint during the planning stage of the build process. A target can define its own filesets.</p>
<h3 id="intellectual-property-ip"><a class="header" href="#intellectual-property-ip">Intellectual Property (IP)</a></h3>
<p>An ip is a project with a manifest file at its root directory. At a minimum, an ip has two attributes: a name and a version.</p>
<h3 id="ip-specification-spec"><a class="header" href="#ip-specification-spec">Ip Specification (spec)</a></h3>
<p>The spec describes the format for identifying and referencing an ip. Each ip in the user's catalog must have a unique spec. The format of a ip's spec is: <code>&lt;name&gt;[:&lt;version&gt;]</code>.</p>
<h3 id="local-ip"><a class="header" href="#local-ip">Local Ip</a></h3>
<p>The local ip is the ip detected from the current working directory on the command-line. Some commands can only be executed from the local ip, such as <code>orbit lock</code> and <code>orbit build</code>.</p>
<h3 id="lockfile"><a class="header" href="#lockfile">Lockfile</a></h3>
<p>A lockfile is a file that exactly describes an ip's dependencies. It is generated and maintained by Orbit. The lockfile should be checked into your version control system for reproducible builds. It is not to be manually edited by the user.</p>
<p>From the lockfile, Orbit is able to download missing dependencies, install missing dependencies, and verify the data integrity of installed dependencies.</p>
<h3 id="manifest-1"><a class="header" href="#manifest-1">Manifest</a></h3>
<p>A manifest is a file that decscribes an ip recognized by Orbit. Manifest files
are exactly named <code>Orbit.toml</code>. The manifest is intended to be written by the user.</p>
<h3 id="orbitlock-1"><a class="header" href="#orbitlock-1">Orbit.lock</a></h3>
<p>See <a href="glossary.html#lockfile">lockfile</a>.</p>
<h3 id="orbittoml"><a class="header" href="#orbittoml">Orbit.toml</a></h3>
<p>See <a href="glossary.html#manifest">manifest</a>.</p>
<h3 id="package"><a class="header" href="#package">Package</a></h3>
<p>See <a href="glossary.html#intellectual-property-ip">IP</a>.</p>
<h3 id="profile"><a class="header" href="#profile">Profile</a></h3>
<p>A profile is a user-defined group of plugins, settings, and/or channels under a single directory. A profile does not necessarily have to have all listed aspects in order to be considered a "profile".</p>
<p>Profiles are useful for quickly sharing and maintaining common development standards and workflows among a team environment.</p>
<h3 id="project"><a class="header" href="#project">Project</a></h3>
<p>A project is a collection of HDL source files and any other required files related to a specific application or library. Placing a manifest in a project makes it an ip.</p>
<h3 id="systemverilog"><a class="header" href="#systemverilog">SystemVerilog</a></h3>
<p>SystemVerilog is a hardware description and hardware verification language used to model, design, simulate, test, and implement electronic systems.</p>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<p>A target is a user-defined command that is to be invoked by Orbit during the execution stage of the build process. A target typically follows 3 steps:</p>
<ol>
<li>Parse the blueprint file generated from the planning stage</li>
<li>Process the listed hdl files using an EDA tool</li>
<li>Test the design or build an output product</li>
</ol>
<p>Targets can accept additional arguments from the command-line and define additional filesets to be collected for the planning stage. Users are encouraged to create and share their own targets.</p>
<h3 id="vhdl"><a class="header" href="#vhdl">VHDL</a></h3>
<p>VHSIC Hardware Design Language (VHDL) is a hardware descrption language to model the behavior of digitally electronic circuits.</p>
<h3 id="verilog"><a class="header" href="#verilog">Verilog</a></h3>
<p>Verilog is a hardware description language to model electronic systems. The final standard (IEEE 1364-2005) for Verilog merged into the SystemVerilog standard. Today, Verilog has been officially part of the SystemVerilog language.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
